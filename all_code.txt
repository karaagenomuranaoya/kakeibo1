

--- FILE: main.dart ---
```dart
import 'package:flutter/material.dart';
import 'screens/input_screen.dart';

void main() {
  runApp(const QuickKakeiboApp());
}

class QuickKakeiboApp extends StatelessWidget {
  const QuickKakeiboApp({super.key});
  @override
  Widget build(BuildContext context) {
    return MaterialApp(
      debugShowCheckedModeBanner: false,
      title: 'Quick Kakeibo',
      theme: ThemeData(useMaterial3: true, colorSchemeSeed: Colors.blue),
      home: const InputScreen(),
    );
  }
}

```


--- FILE: pubspec.yaml ---
```
name: flutter_application_1
description: "A new Flutter project."
# The following line prevents the package from being accidentally published to
# pub.dev using `flutter pub publish`. This is preferred for private packages.
publish_to: 'none' # Remove this line if you wish to publish to pub.dev

# The following defines the version and build number for your application.
# A version number is three numbers separated by dots, like 1.2.43
# followed by an optional build number separated by a +.
# Both the version and the builder number may be overridden in flutter
# build by specifying --build-name and --build-number, respectively.
# In Android, build-name is used as versionName while build-number used as versionCode.
# Read more about Android versioning at https://developer.android.com/studio/publish/versioning
# In iOS, build-name is used as CFBundleShortVersionString while build-number is used as CFBundleVersion.
# Read more about iOS versioning at
# https://developer.apple.com/library/archive/documentation/General/Reference/InfoPlistKeyReference/Articles/CoreFoundationKeys.html
# In Windows, build-name is used as the major, minor, and patch parts
# of the product and file versions while build-number is used as the build suffix.
version: 1.0.0+1

environment:
  sdk: ^3.9.2

# Dependencies specify other packages that your package needs in order to work.
# To automatically upgrade your package dependencies to the latest versions
# consider running `flutter pub upgrade --major-versions`. Alternatively,
# dependencies can be manually updated by changing the version numbers below to
# the latest version available on pub.dev. To see which dependencies have newer
# versions available, run `flutter pub outdated`.
dependencies:
  flutter:
    sdk: flutter

  # The following adds the Cupertino Icons font to your application.
  # Use with the CupertinoIcons class for iOS style icons.
  cupertino_icons: ^1.0.8
  shared_preferences: ^2.5.4

dev_dependencies:
  flutter_test:
    sdk: flutter

  # The "flutter_lints" package below contains a set of recommended lints to
  # encourage good coding practices. The lint set provided by the package is
  # activated in the `analysis_options.yaml` file located at the root of your
  # package. See that file for information about deactivating specific lint
  # rules and activating additional ones.
  flutter_lints: ^5.0.0

# For information on the generic Dart part of this file, see the
# following page: https://dart.dev/tools/pub/pubspec

# The following section is specific to Flutter packages.
flutter:

  # The following line ensures that the Material Icons font is
  # included with your application, so that you can use the icons in
  # the material Icons class.
  uses-material-design: true

  # To add assets to your application, add an assets section, like this:
  # assets:
  #   - images/a_dot_burr.jpeg
  #   - images/a_dot_ham.jpeg

  # An image asset can refer to one or more resolution-specific "variants", see
  # https://flutter.dev/to/resolution-aware-images

  # For details regarding adding assets from package dependencies, see
  # https://flutter.dev/to/asset-from-package

  # To add custom fonts to your application, add a fonts section here,
  # in this "flutter" section. Each entry in this list should have a
  # "family" key with the font family name, and a "fonts" key with a
  # list giving the asset and other descriptors for the font. For
  # example:
  # fonts:
  #   - family: Schyler
  #     fonts:
  #       - asset: fonts/Schyler-Regular.ttf
  #       - asset: fonts/Schyler-Italic.ttf
  #         style: italic
  #   - family: Trajan Pro
  #     fonts:
  #       - asset: fonts/TrajanPro.ttf
  #       - asset: fonts/TrajanPro_Bold.ttf
  #         weight: 700
  #
  # For details regarding fonts from package dependencies,
  # see https://flutter.dev/to/font-from-package

```


--- FILE: analysis_options.yaml ---
```
# This file configures the analyzer, which statically analyzes Dart code to
# check for errors, warnings, and lints.
#
# The issues identified by the analyzer are surfaced in the UI of Dart-enabled
# IDEs (https://dart.dev/tools#ides-and-editors). The analyzer can also be
# invoked from the command line by running `flutter analyze`.

# The following line activates a set of recommended lints for Flutter apps,
# packages, and plugins designed to encourage good coding practices.
include: package:flutter_lints/flutter.yaml

linter:
  # The lint rules applied to this project can be customized in the
  # section below to disable rules from the `package:flutter_lints/flutter.yaml`
  # included above or to enable additional rules. A list of all available lints
  # and their documentation is published at https://dart.dev/lints.
  #
  # Instead of disabling a lint rule for the entire project in the
  # section below, it can also be suppressed for a single line of code
  # or a specific dart file by using the `// ignore: name_of_lint` and
  # `// ignore_for_file: name_of_lint` syntax on the line or in the file
  # producing the lint.
  rules:
    # avoid_print: false  # Uncomment to disable the `avoid_print` rule
    # prefer_single_quotes: true  # Uncomment to enable the `prefer_single_quotes` rule

# Additional information about this file can be found at
# https://dart.dev/guides/language/analysis-options

```


--- FILE: test/widget_test.dart ---
```dart
// This is a basic Flutter widget test.
//
// To perform an interaction with a widget in your test, use the WidgetTester
// utility in the flutter_test package. For example, you can send tap and scroll
// gestures. You can also use WidgetTester to find child widgets in the widget
// tree, read text, and verify that the values of widget properties are correct.

import 'package:flutter/material.dart';
import 'package:flutter_test/flutter_test.dart';

import 'package:flutter_application_1/main.dart';

void main() {
  testWidgets('Counter increments smoke test', (WidgetTester tester) async {
    // Build our app and trigger a frame.
    await tester.pumpWidget(const MyApp());

    // Verify that our counter starts at 0.
    expect(find.text('0'), findsOneWidget);
    expect(find.text('1'), findsNothing);

    // Tap the '+' icon and trigger a frame.
    await tester.tap(find.byIcon(Icons.add));
    await tester.pump();

    // Verify that our counter has incremented.
    expect(find.text('0'), findsNothing);
    expect(find.text('1'), findsOneWidget);
  });
}

```


--- FILE: web/manifest.json ---
```
{
    "name": "flutter_application_1",
    "short_name": "flutter_application_1",
    "start_url": ".",
    "display": "standalone",
    "background_color": "#0175C2",
    "theme_color": "#0175C2",
    "description": "A new Flutter project.",
    "orientation": "portrait-primary",
    "prefer_related_applications": false,
    "icons": [
        {
            "src": "icons/Icon-192.png",
            "sizes": "192x192",
            "type": "image/png"
        },
        {
            "src": "icons/Icon-512.png",
            "sizes": "512x512",
            "type": "image/png"
        },
        {
            "src": "icons/Icon-maskable-192.png",
            "sizes": "192x192",
            "type": "image/png",
            "purpose": "maskable"
        },
        {
            "src": "icons/Icon-maskable-512.png",
            "sizes": "512x512",
            "type": "image/png",
            "purpose": "maskable"
        }
    ]
}

```


--- FILE: flutter_project/main.dart ---
```dart
import 'package:flutter/material.dart';
import 'screens/input_screen.dart';

void main() {
  runApp(const QuickKakeiboApp());
}

class QuickKakeiboApp extends StatelessWidget {
  const QuickKakeiboApp({super.key});
  @override
  Widget build(BuildContext context) {
    return MaterialApp(
      debugShowCheckedModeBanner: false,
      title: 'Quick Kakeibo',
      theme: ThemeData(useMaterial3: true, colorSchemeSeed: Colors.blue),
      home: const InputScreen(),
    );
  }
}

```


--- FILE: flutter_project/pubspec.yaml ---
```
name: flutter_application_1
description: "A new Flutter project."
# The following line prevents the package from being accidentally published to
# pub.dev using `flutter pub publish`. This is preferred for private packages.
publish_to: 'none' # Remove this line if you wish to publish to pub.dev

# The following defines the version and build number for your application.
# A version number is three numbers separated by dots, like 1.2.43
# followed by an optional build number separated by a +.
# Both the version and the builder number may be overridden in flutter
# build by specifying --build-name and --build-number, respectively.
# In Android, build-name is used as versionName while build-number used as versionCode.
# Read more about Android versioning at https://developer.android.com/studio/publish/versioning
# In iOS, build-name is used as CFBundleShortVersionString while build-number is used as CFBundleVersion.
# Read more about iOS versioning at
# https://developer.apple.com/library/archive/documentation/General/Reference/InfoPlistKeyReference/Articles/CoreFoundationKeys.html
# In Windows, build-name is used as the major, minor, and patch parts
# of the product and file versions while build-number is used as the build suffix.
version: 1.0.0+1

environment:
  sdk: ^3.9.2

# Dependencies specify other packages that your package needs in order to work.
# To automatically upgrade your package dependencies to the latest versions
# consider running `flutter pub upgrade --major-versions`. Alternatively,
# dependencies can be manually updated by changing the version numbers below to
# the latest version available on pub.dev. To see which dependencies have newer
# versions available, run `flutter pub outdated`.
dependencies:
  flutter:
    sdk: flutter

  # The following adds the Cupertino Icons font to your application.
  # Use with the CupertinoIcons class for iOS style icons.
  cupertino_icons: ^1.0.8
  shared_preferences: ^2.5.4

dev_dependencies:
  flutter_test:
    sdk: flutter

  # The "flutter_lints" package below contains a set of recommended lints to
  # encourage good coding practices. The lint set provided by the package is
  # activated in the `analysis_options.yaml` file located at the root of your
  # package. See that file for information about deactivating specific lint
  # rules and activating additional ones.
  flutter_lints: ^5.0.0

# For information on the generic Dart part of this file, see the
# following page: https://dart.dev/tools/pub/pubspec

# The following section is specific to Flutter packages.
flutter:

  # The following line ensures that the Material Icons font is
  # included with your application, so that you can use the icons in
  # the material Icons class.
  uses-material-design: true

  # To add assets to your application, add an assets section, like this:
  # assets:
  #   - images/a_dot_burr.jpeg
  #   - images/a_dot_ham.jpeg

  # An image asset can refer to one or more resolution-specific "variants", see
  # https://flutter.dev/to/resolution-aware-images

  # For details regarding adding assets from package dependencies, see
  # https://flutter.dev/to/asset-from-package

  # To add custom fonts to your application, add a fonts section here,
  # in this "flutter" section. Each entry in this list should have a
  # "family" key with the font family name, and a "fonts" key with a
  # list giving the asset and other descriptors for the font. For
  # example:
  # fonts:
  #   - family: Schyler
  #     fonts:
  #       - asset: fonts/Schyler-Regular.ttf
  #       - asset: fonts/Schyler-Italic.ttf
  #         style: italic
  #   - family: Trajan Pro
  #     fonts:
  #       - asset: fonts/TrajanPro.ttf
  #       - asset: fonts/TrajanPro_Bold.ttf
  #         weight: 700
  #
  # For details regarding fonts from package dependencies,
  # see https://flutter.dev/to/font-from-package

```


--- FILE: flutter_project/analysis_options.yaml ---
```
# This file configures the analyzer, which statically analyzes Dart code to
# check for errors, warnings, and lints.
#
# The issues identified by the analyzer are surfaced in the UI of Dart-enabled
# IDEs (https://dart.dev/tools#ides-and-editors). The analyzer can also be
# invoked from the command line by running `flutter analyze`.

# The following line activates a set of recommended lints for Flutter apps,
# packages, and plugins designed to encourage good coding practices.
include: package:flutter_lints/flutter.yaml

linter:
  # The lint rules applied to this project can be customized in the
  # section below to disable rules from the `package:flutter_lints/flutter.yaml`
  # included above or to enable additional rules. A list of all available lints
  # and their documentation is published at https://dart.dev/lints.
  #
  # Instead of disabling a lint rule for the entire project in the
  # section below, it can also be suppressed for a single line of code
  # or a specific dart file by using the `// ignore: name_of_lint` and
  # `// ignore_for_file: name_of_lint` syntax on the line or in the file
  # producing the lint.
  rules:
    # avoid_print: false  # Uncomment to disable the `avoid_print` rule
    # prefer_single_quotes: true  # Uncomment to enable the `prefer_single_quotes` rule

# Additional information about this file can be found at
# https://dart.dev/guides/language/analysis-options

```


--- FILE: flutter_project/test/widget_test.dart ---
```dart
// This is a basic Flutter widget test.
//
// To perform an interaction with a widget in your test, use the WidgetTester
// utility in the flutter_test package. For example, you can send tap and scroll
// gestures. You can also use WidgetTester to find child widgets in the widget
// tree, read text, and verify that the values of widget properties are correct.

import 'package:flutter/material.dart';
import 'package:flutter_test/flutter_test.dart';

import 'package:flutter_application_1/main.dart';

void main() {
  testWidgets('Counter increments smoke test', (WidgetTester tester) async {
    // Build our app and trigger a frame.
    await tester.pumpWidget(const MyApp());

    // Verify that our counter starts at 0.
    expect(find.text('0'), findsOneWidget);
    expect(find.text('1'), findsNothing);

    // Tap the '+' icon and trigger a frame.
    await tester.tap(find.byIcon(Icons.add));
    await tester.pump();

    // Verify that our counter has incremented.
    expect(find.text('0'), findsNothing);
    expect(find.text('1'), findsOneWidget);
  });
}

```


--- FILE: flutter_project/web/manifest.json ---
```
{
    "name": "flutter_application_1",
    "short_name": "flutter_application_1",
    "start_url": ".",
    "display": "standalone",
    "background_color": "#0175C2",
    "theme_color": "#0175C2",
    "description": "A new Flutter project.",
    "orientation": "portrait-primary",
    "prefer_related_applications": false,
    "icons": [
        {
            "src": "icons/Icon-192.png",
            "sizes": "192x192",
            "type": "image/png"
        },
        {
            "src": "icons/Icon-512.png",
            "sizes": "512x512",
            "type": "image/png"
        },
        {
            "src": "icons/Icon-maskable-192.png",
            "sizes": "192x192",
            "type": "image/png",
            "purpose": "maskable"
        },
        {
            "src": "icons/Icon-maskable-512.png",
            "sizes": "512x512",
            "type": "image/png",
            "purpose": "maskable"
        }
    ]
}

```


--- FILE: flutter_project/lib/main.dart ---
```dart
import 'package:flutter/material.dart';
import 'screens/input_screen.dart';

void main() {
  runApp(const QuickKakeiboApp());
}

class QuickKakeiboApp extends StatelessWidget {
  const QuickKakeiboApp({super.key});
  @override
  Widget build(BuildContext context) {
    return MaterialApp(
      debugShowCheckedModeBanner: false,
      title: 'Quick Kakeibo',
      theme: ThemeData(useMaterial3: true, colorSchemeSeed: Colors.blue),
      home: const InputScreen(),
    );
  }
}

```


--- FILE: flutter_project/lib/repositories/transaction_repository.dart ---
```dart
import 'dart:convert';
import 'package:shared_preferences/shared_preferences.dart';
import '../models/transaction_item.dart';

class TransactionRepository {
  static const String _key = 'history';

  // 保存処理
  Future<void> addTransaction(TransactionItem item) async {
    final prefs = await SharedPreferences.getInstance();
    final List<TransactionItem> currentList = await getAllTransactions();

    // 新しいデータを先頭に追加
    currentList.insert(0, item);

    // JSON文字列に変換して保存
    final String jsonString = json.encode(
      currentList.map((e) => e.toJson()).toList(),
    );
    await prefs.setString(_key, jsonString);
  }

  // 全件取得処理
  Future<List<TransactionItem>> getAllTransactions() async {
    final prefs = await SharedPreferences.getInstance();
    final String? jsonString = prefs.getString(_key);

    if (jsonString == null) return [];

    final List<dynamic> jsonList = json.decode(jsonString);
    return jsonList.map((e) => TransactionItem.fromJson(e)).toList();
  }
}

```


--- FILE: flutter_project/lib/models/transaction_item.dart ---
```dart
class TransactionItem {
  final int amount;
  final String expense;
  final String payment;
  final DateTime date;

  TransactionItem({
    required this.amount,
    required this.expense,
    required this.payment,
    required this.date,
  });

  // 表示用日付フォーマット
  String get displayDate {
    return "${date.month}/${date.day} ${date.hour}:${date.minute.toString().padLeft(2, '0')}";
  }

  // JSON保存用: Mapに変換
  Map<String, dynamic> toJson() {
    return {
      'amount': amount,
      'expense': expense,
      'payment': payment,
      'date_iso': date.toIso8601String(),
    };
  }

  // 読み込み用: Mapから生成
  factory TransactionItem.fromJson(Map<String, dynamic> json) {
    return TransactionItem(
      amount: json['amount'] as int,
      expense: json['expense'] as String,
      payment: json['payment'] as String,
      date: DateTime.parse(json['date_iso'] as String),
    );
  }
}

```


--- FILE: flutter_project/lib/models/category_tag.dart ---
```dart
import 'package:flutter/material.dart';

class CategoryTag {
  final String label;
  final Color color;
  final bool isCircle;

  const CategoryTag(this.label, this.color, {this.isCircle = false});
}

// 定数データ
final List<CategoryTag> expenseTags = [
  CategoryTag('食費', Colors.orange, isCircle: true),
  CategoryTag('日用品', Colors.green, isCircle: true),
  CategoryTag('雑費', Colors.blueGrey, isCircle: true),
  CategoryTag('交際費', Colors.pink, isCircle: true),
  CategoryTag('趣味', Colors.purple, isCircle: true),
];

final List<CategoryTag> paymentTags = [
  CategoryTag('現金', Colors.grey),
  CategoryTag('クレカ', Colors.blue),
  CategoryTag('PayPay', Colors.redAccent),
  CategoryTag('Suica', Colors.lightGreen),
];

```


--- FILE: flutter_project/lib/screens/history_screen.dart ---
```dart
import 'package:flutter/material.dart';
import '../models/transaction_item.dart';
import '../repositories/transaction_repository.dart';

class HistoryScreen extends StatefulWidget {
  final String filterValue;
  final String filterKey; // 'expense' or 'payment'
  final Color? color;

  const HistoryScreen({
    super.key,
    required this.filterValue,
    required this.filterKey,
    this.color,
  });

  @override
  State<HistoryScreen> createState() => _HistoryScreenState();
}

class _HistoryScreenState extends State<HistoryScreen> {
  List<TransactionItem> _history = [];
  final TransactionRepository _repository = TransactionRepository();

  @override
  void initState() {
    super.initState();
    _load();
  }

  Future<void> _load() async {
    final allItems = await _repository.getAllTransactions();
    setState(() {
      _history = allItems.where((i) {
        if (widget.filterKey == 'expense')
          return i.expense == widget.filterValue;
        if (widget.filterKey == 'payment')
          return i.payment == widget.filterValue;
        return false;
      }).toList();
    });
  }

  @override
  Widget build(BuildContext context) {
    int total = _history.fold(0, (s, i) => s + i.amount);
    return Scaffold(
      appBar: AppBar(title: Text(widget.filterValue)),
      body: Column(
        children: [
          Container(
            width: double.infinity,
            padding: const EdgeInsets.all(20),
            color: widget.color?.withOpacity(0.1) ?? Colors.blue.shade50,
            child: Center(
              child: Column(
                children: [
                  Text(
                    widget.filterKey == 'expense' ? '費目累計' : '支払い累計',
                    style: const TextStyle(fontSize: 14, color: Colors.grey),
                  ),
                  Text(
                    '¥ $total',
                    style: TextStyle(
                      fontSize: 28,
                      fontWeight: FontWeight.bold,
                      color: widget.color ?? Colors.black,
                    ),
                  ),
                ],
              ),
            ),
          ),
          Expanded(
            child: ListView.builder(
              itemCount: _history.length,
              itemBuilder: (c, i) => ListTile(
                leading: Icon(
                  widget.filterKey == 'payment' ? Icons.payment : Icons.label,
                  color: widget.color,
                ),
                title: Text(
                  '¥${_history[i].amount}',
                  style: const TextStyle(fontWeight: FontWeight.bold),
                ),
                subtitle: Text(
                  "${_history[i].displayDate}  /  ${widget.filterKey == 'expense' ? _history[i].payment : _history[i].expense}",
                ),
              ),
            ),
          ),
        ],
      ),
    );
  }
}

```


--- FILE: flutter_project/lib/screens/input_screen.dart ---
```dart
import 'package:flutter/material.dart';
import '../models/category_tag.dart';
import '../models/transaction_item.dart';
import '../repositories/transaction_repository.dart';
import '../widgets/category_selector.dart';
import '../widgets/app_drawer.dart';

class InputScreen extends StatefulWidget {
  const InputScreen({super.key});
  @override
  State<InputScreen> createState() => _InputScreenState();
}

class _InputScreenState extends State<InputScreen> {
  final TextEditingController _amountController = TextEditingController();
  final FocusNode _amountFocusNode = FocusNode();
  final GlobalKey<ScaffoldState> _scaffoldKey = GlobalKey<ScaffoldState>();
  final TransactionRepository _repository = TransactionRepository();

  int? _selectedExpenseIndex;
  int? _selectedPaymentIndex;
  DateTime _selectedDate = DateTime.now();

  @override
  void dispose() {
    _amountFocusNode.dispose();
    _amountController.dispose();
    super.dispose();
  }

  Future<void> _pickDate() async {
    final DateTime? picked = await showDatePicker(
      context: context,
      initialDate: _selectedDate,
      firstDate: DateTime(2000),
      lastDate: DateTime(2101),
    );
    if (picked != null) setState(() => _selectedDate = picked);
  }

  Future<void> _saveData({required bool shouldDismissKeyboard}) async {
    final amountText = _amountController.text;
    if (amountText.isEmpty || amountText == "0") {
      if (shouldDismissKeyboard) _amountFocusNode.unfocus();
      return;
    }

    final newItem = TransactionItem(
      amount: int.tryParse(amountText) ?? 0,
      expense: _selectedExpenseIndex != null
          ? expenseTags[_selectedExpenseIndex!].label
          : '未分類',
      payment: _selectedPaymentIndex != null
          ? paymentTags[_selectedPaymentIndex!].label
          : '現金',
      date: DateTime(
        _selectedDate.year,
        _selectedDate.month,
        _selectedDate.day,
        DateTime.now().hour,
        DateTime.now().minute,
      ),
    );

    await _repository.addTransaction(newItem);

    setState(() {
      _amountController.clear();
      _selectedExpenseIndex = null;
      _selectedPaymentIndex = null;
    });

    if (shouldDismissKeyboard) _amountFocusNode.unfocus();

    if (mounted) {
      ScaffoldMessenger.of(context).showSnackBar(
        const SnackBar(
          content: Text('保存しました'),
          duration: Duration(milliseconds: 500),
        ),
      );
    }
  }

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      key: _scaffoldKey,
      onDrawerChanged: (isOpened) {
        if (isOpened) _amountFocusNode.unfocus();
      },
      drawer: const AppDrawer(),
      body: GestureDetector(
        onTap: () => FocusScope.of(context).unfocus(),
        behavior: HitTestBehavior.opaque,
        child: Stack(
          children: [
            Column(
              children: [
                Expanded(
                  child: SingleChildScrollView(
                    padding: const EdgeInsets.fromLTRB(20, 80, 20, 0),
                    child: Column(
                      children: [
                        _buildAmountInput(),
                        const SizedBox(height: 15),
                        CategorySelector(
                          tags: expenseTags,
                          selectedIndex: _selectedExpenseIndex,
                          rowCount: 2,
                          onSelected: (i) =>
                              setState(() => _selectedExpenseIndex = i),
                        ),
                        const Divider(
                          height: 30,
                          thickness: 1,
                          color: Colors.black12,
                        ),
                        CategorySelector(
                          tags: paymentTags,
                          selectedIndex: _selectedPaymentIndex,
                          rowCount: 2,
                          onSelected: (i) =>
                              setState(() => _selectedPaymentIndex = i),
                        ),
                        const SizedBox(height: 20),
                      ],
                    ),
                  ),
                ),
                _buildActionButtons(),
              ],
            ),
            _buildMenuButton(),
          ],
        ),
      ),
    );
  }

  Widget _buildAmountInput() {
    return Row(
      crossAxisAlignment: CrossAxisAlignment.center,
      children: [
        const Text(
          '¥ ',
          style: TextStyle(
            fontSize: 44,
            color: Colors.black,
            fontWeight: FontWeight.bold,
          ),
        ),
        Expanded(
          child: TextField(
            controller: _amountController,
            focusNode: _amountFocusNode,
            autofocus: true,
            keyboardType: TextInputType.number,
            textAlign: TextAlign.right,
            style: const TextStyle(fontSize: 44, fontWeight: FontWeight.bold),
            decoration: const InputDecoration(
              hintText: '0',
              enabledBorder: UnderlineInputBorder(
                borderSide: BorderSide(color: Colors.black12, width: 2),
              ),
            ),
          ),
        ),
        const SizedBox(width: 10),
        Padding(
          padding: const EdgeInsets.only(top: 12),
          child: IconButton(
            onPressed: _pickDate,
            icon: Column(
              mainAxisSize: MainAxisSize.min,
              children: [
                const Icon(Icons.calendar_today, size: 20, color: Colors.blue),
                const SizedBox(height: 2),
                Text(
                  "${_selectedDate.month}/${_selectedDate.day}",
                  style: const TextStyle(
                    fontSize: 11,
                    color: Colors.blue,
                    fontWeight: FontWeight.bold,
                  ),
                ),
              ],
            ),
          ),
        ),
      ],
    );
  }

  Widget _buildActionButtons() {
    return Padding(
      padding: const EdgeInsets.symmetric(horizontal: 20, vertical: 15),
      child: Row(
        children: [
          Expanded(
            child: OutlinedButton(
              onPressed: () => _saveData(shouldDismissKeyboard: false),
              style: OutlinedButton.styleFrom(
                padding: const EdgeInsets.symmetric(vertical: 12),
              ),
              child: const Text('次へ'),
            ),
          ),
          const SizedBox(width: 10),
          Expanded(
            child: ElevatedButton(
              onPressed: () => _saveData(shouldDismissKeyboard: true),
              style: ElevatedButton.styleFrom(
                padding: const EdgeInsets.symmetric(vertical: 12),
                backgroundColor: Colors.blue,
                foregroundColor: Colors.white,
              ),
              child: const Text('完了'),
            ),
          ),
        ],
      ),
    );
  }

  Widget _buildMenuButton() {
    return Positioned(
      top: 45,
      left: 15,
      child: Container(
        decoration: const BoxDecoration(
          color: Colors.white,
          shape: BoxShape.circle,
          boxShadow: [BoxShadow(color: Colors.black12, blurRadius: 4)],
        ),
        child: IconButton(
          icon: const Icon(Icons.menu, color: Colors.blue, size: 24),
          onPressed: () => _scaffoldKey.currentState?.openDrawer(),
        ),
      ),
    );
  }
}

```


--- FILE: flutter_project/lib/screens/monthly_report_screen.dart ---
```dart
import 'package:flutter/material.dart';
import '../models/category_tag.dart';
import '../models/transaction_item.dart';
import '../repositories/transaction_repository.dart';

class MonthlyHistoryScreen extends StatefulWidget {
  const MonthlyHistoryScreen({super.key});
  @override
  State<MonthlyHistoryScreen> createState() => _MonthlyHistoryScreenState();
}

class _MonthlyHistoryScreenState extends State<MonthlyHistoryScreen> {
  final PageController _pageController = PageController(initialPage: 1000);

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      appBar: AppBar(title: const Text('月別レポート')),
      body: PageView.builder(
        controller: _pageController,
        itemBuilder: (context, index) {
          final d = DateTime(
            DateTime.now().year,
            DateTime.now().month + (index - 1000),
          );
          return MonthPage(year: d.year, month: d.month);
        },
      ),
    );
  }
}

class MonthPage extends StatefulWidget {
  final int year;
  final int month;
  const MonthPage({super.key, required this.year, required this.month});
  @override
  State<MonthPage> createState() => _MonthPageState();
}

class _MonthPageState extends State<MonthPage> {
  List<TransactionItem> _history = [];
  final TransactionRepository _repository = TransactionRepository();

  @override
  void initState() {
    super.initState();
    _load();
  }

  Future<void> _load() async {
    final allItems = await _repository.getAllTransactions();
    setState(() {
      _history = allItems.where((i) {
        return i.date.year == widget.year && i.date.month == widget.month;
      }).toList();
    });
  }

  @override
  Widget build(BuildContext context) {
    int total = _history.fold(0, (s, i) => s + i.amount);
    return Column(
      children: [
        Padding(
          padding: const EdgeInsets.all(10),
          child: Text(
            "${widget.year}年 ${widget.month}月",
            style: const TextStyle(fontSize: 20, fontWeight: FontWeight.bold),
          ),
        ),
        _buildSummaryCard(total),
        Expanded(
          child: ListView.builder(
            itemCount: _history.length,
            itemBuilder: (c, i) => ListTile(
              title: Text('¥${_history[i].amount} (${_history[i].expense})'),
              subtitle: Text(
                '${_history[i].payment} / ${_history[i].displayDate}',
              ),
            ),
          ),
        ),
      ],
    );
  }

  Widget _buildSummaryCard(int total) {
    return Card(
      margin: const EdgeInsets.all(15),
      color: Colors.blue.shade50,
      child: Padding(
        padding: const EdgeInsets.all(15),
        child: Column(
          children: [
            Text(
              '¥ $total',
              style: const TextStyle(fontSize: 32, fontWeight: FontWeight.bold),
            ),
            const Divider(),
            Wrap(
              spacing: 10,
              children: expenseTags.map((t) {
                int s = _history
                    .where((i) => i.expense == t.label)
                    .fold(0, (sum, i) => sum + i.amount);
                return s > 0
                    ? Text(
                        '${t.label}: ¥$s',
                        style: TextStyle(
                          color: t.color,
                          fontWeight: FontWeight.bold,
                        ),
                      )
                    : const SizedBox.shrink();
              }).toList(),
            ),
          ],
        ),
      ),
    );
  }
}

```


--- FILE: flutter_project/lib/widgets/category_selector.dart ---
```dart
import 'package:flutter/material.dart';
import '../models/category_tag.dart';

class CategorySelector extends StatelessWidget {
  final List<CategoryTag> tags;
  final int? selectedIndex;
  final int rowCount;
  final Function(int) onSelected;

  const CategorySelector({
    super.key,
    required this.tags,
    required this.selectedIndex,
    required this.rowCount,
    required this.onSelected,
  });

  @override
  Widget build(BuildContext context) {
    return SizedBox(
      height: rowCount == 2 ? 100 : 50,
      child: GridView.builder(
        scrollDirection: Axis.horizontal,
        gridDelegate: SliverGridDelegateWithFixedCrossAxisCount(
          crossAxisCount: rowCount,
          mainAxisSpacing: 6,
          crossAxisSpacing: 6,
          childAspectRatio: rowCount == 2 ? 0.45 : 0.4,
        ),
        itemCount: tags.length,
        itemBuilder: (context, index) {
          final tag = tags[index];
          final isSelected = selectedIndex == index;
          return ChoiceChip(
            label: Text(tag.label, style: const TextStyle(fontSize: 12)),
            selected: isSelected,
            onSelected: (_) => onSelected(index),
            shape: tag.isCircle
                ? const StadiumBorder()
                : RoundedRectangleBorder(
                    borderRadius: BorderRadius.circular(8),
                  ),
            selectedColor: tag.color.withOpacity(0.3),
            visualDensity: VisualDensity.compact,
          );
        },
      ),
    );
  }
}

```


--- FILE: flutter_project/lib/widgets/app_drawer.dart ---
```dart
import 'package:flutter/material.dart';
import '../models/category_tag.dart';
import '../screens/monthly_report_screen.dart';
import '../screens/history_screen.dart';

class AppDrawer extends StatelessWidget {
  const AppDrawer({super.key});

  @override
  Widget build(BuildContext context) {
    return Drawer(
      child: ListView(
        padding: EdgeInsets.zero,
        children: [
          const DrawerHeader(
            decoration: BoxDecoration(color: Colors.blue),
            child: Text(
              'メニュー',
              style: TextStyle(color: Colors.white, fontSize: 24),
            ),
          ),
          ListTile(
            leading: const Icon(Icons.calendar_month),
            title: const Text('月別レポート'),
            onTap: () {
              Navigator.pop(context);
              Navigator.push(
                context,
                MaterialPageRoute(
                  builder: (context) => const MonthlyHistoryScreen(),
                ),
              );
            },
          ),
          const Divider(),
          _buildSectionHeader("費目別"),
          ...expenseTags.map(
            (tag) => _buildFilterTile(context, tag, 'expense'),
          ),
          const SizedBox(height: 15),
          const Divider(),
          _buildSectionHeader("支払い方法別"),
          ...paymentTags.map(
            (tag) => _buildFilterTile(context, tag, 'payment'),
          ),
          const SizedBox(height: 20),
        ],
      ),
    );
  }

  Widget _buildSectionHeader(String title) {
    return Padding(
      padding: const EdgeInsets.only(left: 16, top: 10, bottom: 5),
      child: Text(
        title,
        style: const TextStyle(color: Colors.grey, fontSize: 12),
      ),
    );
  }

  Widget _buildFilterTile(
    BuildContext context,
    CategoryTag tag,
    String filterKey,
  ) {
    return ListTile(
      leading: Icon(
        filterKey == 'payment' ? Icons.payment : Icons.label,
        color: tag.color,
      ),
      title: Text(tag.label),
      onTap: () {
        Navigator.pop(context);
        Navigator.push(
          context,
          MaterialPageRoute(
            builder: (context) => HistoryScreen(
              filterValue: tag.label,
              filterKey: filterKey,
              color: tag.color,
            ),
          ),
        );
      },
    );
  }
}

```


--- FILE: lib/main.dart ---
```dart
import 'package:flutter/material.dart';
import 'screens/input_screen.dart';

void main() {
  runApp(const QuickKakeiboApp());
}

class QuickKakeiboApp extends StatelessWidget {
  const QuickKakeiboApp({super.key});
  @override
  Widget build(BuildContext context) {
    return MaterialApp(
      debugShowCheckedModeBanner: false,
      title: 'Quick Kakeibo',
      theme: ThemeData(useMaterial3: true, colorSchemeSeed: Colors.blue),
      home: const InputScreen(),
    );
  }
}

```


--- FILE: lib/repositories/settings_repository.dart ---
```dart
import 'package:flutter/material.dart';
import 'package:shared_preferences/shared_preferences.dart';
import '../models/category_tag.dart';

// ショートカット用のデータモデル
class ShortcutItem {
  final String label;
  final String key; // 'expense' or 'payment'
  final Color color;
  final IconData icon;
  final String id; // 保存用の識別子

  ShortcutItem({
    required this.label,
    required this.key,
    required this.color,
    required this.icon,
    required this.id,
  });
}

class SettingsRepository {
  static const String _key = 'shortcut_settings';
  static const String _defaultPaymentKey = 'default_payment_label'; // 追加

  // 全ての選択可能なショートカット候補
  List<ShortcutItem> getAllCandidates() {
    List<ShortcutItem> items = [];

    // 1. デフォルト（費目）
    items.add(
      ShortcutItem(
        label: 'デフォルト',
        key: 'expense',
        color: Colors.blueGrey,
        icon: Icons.bookmarks,
        id: 'def_expense',
      ),
    );

    // 2. 費目リスト
    for (var tag in expenseTags) {
      items.add(
        ShortcutItem(
          label: tag.label,
          key: 'expense',
          color: tag.color,
          icon: _getIconForLabel(tag.label),
          id: 'exp_${tag.label}',
        ),
      );
    }

    // 3. デフォルト（支払い・現金含む）
    items.add(
      ShortcutItem(
        label: 'デフォルト',
        key: 'payment',
        color: Colors.grey,
        icon: Icons.wallet, // お財布アイコン
        id: 'def_payment',
      ),
    );

    // 4. 支払い方法リスト
    for (var tag in paymentTags) {
      items.add(
        ShortcutItem(
          label: tag.label,
          key: 'payment',
          color: tag.color,
          icon: tag.label == 'クレジットカード' ? Icons.credit_card : Icons.payment,
          id: 'pay_${tag.label}',
        ),
      );
    }

    return items;
  }

  // 初期設定（保存データがない場合）
  List<String> get _defaultShortcutIds => [
    'def_expense', // デフォルト
    'exp_食費', // 食費
    'pay_クレジットカード', // クレカ
  ];

  // 保存されたショートカットIDリストを取得
  Future<List<String>> loadShortcutIds() async {
    final prefs = await SharedPreferences.getInstance();
    return prefs.getStringList(_key) ?? _defaultShortcutIds;
  }

  // ショートカットIDリストを保存
  Future<void> saveShortcutIds(List<String> ids) async {
    final prefs = await SharedPreferences.getInstance();
    await prefs.setStringList(_key, ids);
  }

  // IDリストから実際のオブジェクトリストへ変換して取得
  Future<List<ShortcutItem>> getActiveShortcuts() async {
    final savedIds = await loadShortcutIds();
    final all = getAllCandidates();

    // 保存された順序を維持してリストを作成
    List<ShortcutItem> active = [];
    for (var id in savedIds) {
      try {
        final item = all.firstWhere((e) => e.id == id);
        active.add(item);
      } catch (e) {
        // 定義が変わってIDが見つからない場合はスキップ
      }
    }
    return active;
  }

  // アイコンの自動判定（簡易実装）
  IconData _getIconForLabel(String label) {
    if (label.contains('食')) return Icons.restaurant;
    if (label.contains('日用')) return Icons.shopping_bag;
    if (label.contains('交際')) return Icons.people;
    if (label.contains('趣味')) return Icons.sports_esports;
    if (label.contains('雑')) return Icons.auto_awesome;
    return Icons.label;
  }

  // ▼▼▼ 以下、追加機能 ▼▼▼

  // デフォルトの支払い方法を取得
  Future<String?> loadDefaultPaymentMethod() async {
    final prefs = await SharedPreferences.getInstance();
    return prefs.getString(_defaultPaymentKey);
  }

  // デフォルトの支払い方法を保存
  Future<void> saveDefaultPaymentMethod(String label) async {
    final prefs = await SharedPreferences.getInstance();
    await prefs.setString(_defaultPaymentKey, label);
  }

  // 設定を削除（「設定なし」に戻す場合など）
  Future<void> clearDefaultPaymentMethod() async {
    final prefs = await SharedPreferences.getInstance();
    await prefs.remove(_defaultPaymentKey);
  }
}

```


--- FILE: lib/repositories/transaction_repository.dart ---
```dart
import 'dart:convert';
import 'package:shared_preferences/shared_preferences.dart';
import '../models/transaction_item.dart';

class TransactionRepository {
  static const String _key = 'history';

  // 保存処理
  Future<void> addTransaction(TransactionItem item) async {
    final prefs = await SharedPreferences.getInstance();
    final List<TransactionItem> currentList = await getAllTransactions();

    // 新しいデータを先頭に追加
    currentList.insert(0, item);

    // JSON文字列に変換して保存
    final String jsonString = json.encode(
      currentList.map((e) => e.toJson()).toList(),
    );
    await prefs.setString(_key, jsonString);
  }

  // 全件取得処理
  Future<List<TransactionItem>> getAllTransactions() async {
    final prefs = await SharedPreferences.getInstance();
    final String? jsonString = prefs.getString(_key);

    if (jsonString == null) return [];

    final List<dynamic> jsonList = json.decode(jsonString);
    return jsonList.map((e) => TransactionItem.fromJson(e)).toList();
  }
}

```


--- FILE: lib/models/transaction_item.dart ---
```dart
class TransactionItem {
  final int amount;
  final String expense;
  final String payment;
  final DateTime date;
  final String? memo; // 追加: 任意のメモ

  TransactionItem({
    required this.amount,
    required this.expense,
    required this.payment,
    required this.date,
    this.memo,
  });

  // 表示用日付フォーマット
  String get displayDate {
    return "${date.month}/${date.day} ${date.hour}:${date.minute.toString().padLeft(2, '0')}";
  }

  // JSON保存用: Mapに変換
  Map<String, dynamic> toJson() {
    return {
      'amount': amount,
      'expense': expense,
      'payment': payment,
      'date_iso': date.toIso8601String(),
      'memo': memo, // 追加
    };
  }

  // 読み込み用: Mapから生成
  factory TransactionItem.fromJson(Map<String, dynamic> json) {
    return TransactionItem(
      amount: json['amount'] as int,
      expense: json['expense'] as String,
      payment: json['payment'] as String,
      date: DateTime.parse(json['date_iso'] as String),
      memo: json['memo'] as String?, // 追加
    );
  }
}

```


--- FILE: lib/models/category_tag.dart ---
```dart
import 'package:flutter/material.dart';

class CategoryTag {
  final String label;
  final Color color;
  final bool isCircle;

  const CategoryTag(this.label, this.color, {this.isCircle = false});
}

// 定数データ
final List<CategoryTag> expenseTags = [
  // ▼▼ 修正: 「デフォルト」は選択肢には表示しないため削除 ▼▼
  CategoryTag('食費', Colors.orange, isCircle: true),
  CategoryTag('日用品', Colors.green, isCircle: true),
  CategoryTag('雑費', Colors.blueGrey, isCircle: true),
  CategoryTag('交際費', Colors.pink, isCircle: true),
  CategoryTag('趣味', Colors.purple, isCircle: true),
];

final List<CategoryTag> paymentTags = [
  // ▼▼ 修正: 「現金」を選択肢として復活 ▼▼
  CategoryTag('現金', Colors.grey),
  CategoryTag('クレジットカード', Colors.blue),
  CategoryTag('PayPay', Colors.redAccent),
  CategoryTag('Suica', Colors.lightGreen),
];

```


--- FILE: lib/screens/history_screen.dart ---
```dart
import 'package:flutter/material.dart';
import '../models/transaction_item.dart';
import '../repositories/transaction_repository.dart';

class HistoryScreen extends StatefulWidget {
  final String filterValue;
  final String filterKey; // 'expense' or 'payment'
  final Color? color;

  const HistoryScreen({
    super.key,
    required this.filterValue,
    required this.filterKey,
    this.color,
  });

  @override
  State<HistoryScreen> createState() => _HistoryScreenState();
}

class _HistoryScreenState extends State<HistoryScreen> {
  List<TransactionItem> _allHistory = [];
  final TransactionRepository _repository = TransactionRepository();

  final PageController _pageController = PageController(initialPage: 1000);
  int _currentPage = 1000;

  @override
  void initState() {
    super.initState();
    _load();
  }

  Future<void> _load() async {
    final allItems = await _repository.getAllTransactions();
    setState(() {
      _allHistory = allItems.where((i) {
        if (widget.filterKey == 'expense') {
          return i.expense == widget.filterValue;
        }
        if (widget.filterKey == 'payment') {
          return i.payment == widget.filterValue;
        }
        return false;
      }).toList();
    });
  }

  DateTime _getDateForPage(int page) {
    final now = DateTime.now();
    return DateTime(now.year, now.month + (page - 1000));
  }

  @override
  Widget build(BuildContext context) {
    final currentMonthDate = _getDateForPage(_currentPage);

    return Scaffold(
      appBar: AppBar(title: Text(widget.filterValue), centerTitle: true),
      body: Column(
        children: [
          Container(
            padding: const EdgeInsets.symmetric(vertical: 10),
            color: Colors.white,
            child: Row(
              mainAxisAlignment: MainAxisAlignment.center,
              children: [
                IconButton(
                  onPressed: () {
                    _pageController.previousPage(
                      duration: const Duration(milliseconds: 300),
                      curve: Curves.easeInOut,
                    );
                  },
                  icon: const Icon(Icons.chevron_left),
                ),
                Padding(
                  padding: const EdgeInsets.symmetric(horizontal: 20),
                  child: Text(
                    "${currentMonthDate.year}年 ${currentMonthDate.month}月",
                    style: const TextStyle(
                      fontSize: 18,
                      fontWeight: FontWeight.bold,
                    ),
                  ),
                ),
                IconButton(
                  onPressed: () {
                    _pageController.nextPage(
                      duration: const Duration(milliseconds: 300),
                      curve: Curves.easeInOut,
                    );
                  },
                  icon: const Icon(Icons.chevron_right),
                ),
              ],
            ),
          ),

          Expanded(
            child: PageView.builder(
              controller: _pageController,
              onPageChanged: (index) {
                setState(() {
                  _currentPage = index;
                });
              },
              itemBuilder: (context, index) {
                return _buildMonthContent(index);
              },
            ),
          ),
        ],
      ),
    );
  }

  Widget _buildMonthContent(int pageIndex) {
    final date = _getDateForPage(pageIndex);
    final monthData = _allHistory.where((i) {
      return i.date.year == date.year && i.date.month == date.month;
    }).toList();

    int total = monthData.fold(0, (s, i) => s + i.amount);

    return Column(
      children: [
        Container(
          width: double.infinity,
          padding: const EdgeInsets.symmetric(vertical: 20, horizontal: 20),
          color: widget.color?.withOpacity(0.1) ?? Colors.blue.shade50,
          child: Center(
            child: Column(
              children: [
                Text(
                  '${date.month}月の合計',
                  style: const TextStyle(fontSize: 14, color: Colors.grey),
                ),
                Text(
                  '¥ $total',
                  style: TextStyle(
                    fontSize: 32,
                    fontWeight: FontWeight.bold,
                    color: widget.color ?? Colors.black,
                  ),
                ),
              ],
            ),
          ),
        ),

        Expanded(
          child: monthData.isEmpty
              ? const Center(
                  child: Text('履歴はありません', style: TextStyle(color: Colors.grey)),
                )
              : ListView.builder(
                  padding: const EdgeInsets.only(top: 10),
                  itemCount: monthData.length,
                  itemBuilder: (c, i) {
                    final item = monthData[i];

                    String detail = "";
                    if (widget.filterKey == 'expense') {
                      if (item.payment != 'デフォルト')
                        detail = "  /  ${item.payment}";
                    } else {
                      if (item.expense != 'デフォルト')
                        detail = "  /  ${item.expense}";
                    }

                    return ListTile(
                      leading: Icon(
                        widget.filterKey == 'payment'
                            ? Icons.payment
                            : Icons.label,
                        color: widget.color,
                      ),
                      title: Row(
                        children: [
                          Text(
                            '¥${item.amount}',
                            style: const TextStyle(fontWeight: FontWeight.bold),
                          ),
                          // メモがある場合はアイコンを表示
                          if (item.memo != null && item.memo!.isNotEmpty) ...[
                            const SizedBox(width: 8),
                            const Icon(
                              Icons.note,
                              size: 16,
                              color: Colors.grey,
                            ),
                          ],
                        ],
                      ),
                      subtitle: Column(
                        crossAxisAlignment: CrossAxisAlignment.start,
                        children: [
                          Text("${item.displayDate}$detail"),
                          // メモの内容を表示
                          if (item.memo != null && item.memo!.isNotEmpty)
                            Text(
                              item.memo!,
                              style: const TextStyle(
                                color: Colors.blueGrey,
                                fontSize: 12,
                              ),
                            ),
                        ],
                      ),
                    );
                  },
                ),
        ),
      ],
    );
  }
}

```


--- FILE: lib/screens/settings_screen.dart ---
```dart
import 'package:flutter/material.dart';
import '../repositories/settings_repository.dart';
import '../models/category_tag.dart';

class SettingsScreen extends StatefulWidget {
  const SettingsScreen({super.key});

  @override
  State<SettingsScreen> createState() => _SettingsScreenState();
}

class _SettingsScreenState extends State<SettingsScreen> {
  final SettingsRepository _repository = SettingsRepository();
  List<ShortcutItem> _allCandidates = [];
  List<String> _currentIds = [];
  String? _defaultPaymentLabel;

  @override
  void initState() {
    super.initState();
    _load();
  }

  Future<void> _load() async {
    final candidates = _repository.getAllCandidates();
    final ids = await _repository.loadShortcutIds();
    final defPayment = await _repository.loadDefaultPaymentMethod();
    setState(() {
      _allCandidates = candidates;
      _currentIds = ids;
      _defaultPaymentLabel = defPayment;
    });
  }

  Future<void> _toggle(String id, bool isEnabled) async {
    setState(() {
      if (isEnabled) {
        // 追加: 末尾に追加
        if (!_currentIds.contains(id)) {
          _currentIds.add(id);
        }
      } else {
        // 削除
        _currentIds.remove(id);
      }
    });
    await _repository.saveShortcutIds(_currentIds);
  }

  Future<void> _changeDefaultPayment(String? newValue) async {
    if (newValue == null) {
      await _repository.clearDefaultPaymentMethod();
    } else {
      await _repository.saveDefaultPaymentMethod(newValue);
    }
    setState(() {
      _defaultPaymentLabel = newValue;
    });
  }

  @override
  Widget build(BuildContext context) {
    // 費目グループと支払いグループに分ける
    final expenseItems = _allCandidates
        .where((i) => i.key == 'expense')
        .toList();
    final paymentItems = _allCandidates
        .where((i) => i.key == 'payment')
        .toList();

    return Scaffold(
      appBar: AppBar(title: const Text('設定')),
      body: ListView(
        children: [
          _buildHeader('入力の初期設定'),
          ListTile(
            title: const Text('デフォルトの支払い方法'),
            subtitle: const Text('入力画面を開いた時に最初から選択状態にします'),
            trailing: DropdownButton<String>(
              value: _defaultPaymentLabel,
              hint: const Text('指定なし'),
              underline: Container(), // 下線を消す
              items: [
                const DropdownMenuItem(value: null, child: Text('指定なし')),
                ...paymentTags.map((tag) {
                  return DropdownMenuItem(
                    value: tag.label,
                    child: Text(tag.label, style: TextStyle(color: tag.color)),
                  );
                }),
              ],
              onChanged: _changeDefaultPayment,
            ),
          ),
          const Divider(),
          _buildHeader('ホーム画面のショートカット'),
          const Padding(
            padding: EdgeInsets.symmetric(horizontal: 16, vertical: 8),
            child: Text(
              'ホーム画面中央に表示するボタンを選択してください。\n3つ程度がレイアウト的に最適です。',
              style: TextStyle(color: Colors.grey, fontSize: 12),
            ),
          ),
          const Divider(),
          _buildSectionLabel('費目'),
          ...expenseItems.map((item) => _buildSwitchTile(item)),
          const Divider(),
          _buildSectionLabel('支払い方法'),
          ...paymentItems.map((item) => _buildSwitchTile(item)),
          const SizedBox(height: 50),
        ],
      ),
    );
  }

  Widget _buildHeader(String title) {
    return Container(
      padding: const EdgeInsets.all(16),
      color: Colors.blue.withOpacity(0.1),
      child: Text(
        title,
        style: const TextStyle(
          fontSize: 18,
          fontWeight: FontWeight.bold,
          color: Colors.blue,
        ),
      ),
    );
  }

  Widget _buildSectionLabel(String label) {
    return Padding(
      padding: const EdgeInsets.fromLTRB(16, 16, 16, 8),
      child: Text(
        label,
        style: const TextStyle(fontWeight: FontWeight.bold, color: Colors.grey),
      ),
    );
  }

  Widget _buildSwitchTile(ShortcutItem item) {
    final isSelected = _currentIds.contains(item.id);
    return SwitchListTile(
      title: Text(item.label),
      subtitle: item.label == 'デフォルト'
          ? Text(item.key == 'expense' ? '未分類の費目' : '現金などのデフォルト支払い')
          : null,
      secondary: CircleAvatar(
        backgroundColor: item.color.withOpacity(0.1),
        child: Icon(item.icon, color: item.color, size: 20),
      ),
      value: isSelected,
      onChanged: (val) => _toggle(item.id, val),
      activeColor: Colors.blue,
    );
  }
}

```


--- FILE: lib/screens/input_screen.dart ---
```dart
import 'package:flutter/material.dart';
import '../models/category_tag.dart';
import '../models/transaction_item.dart';
import '../repositories/transaction_repository.dart';
import '../repositories/settings_repository.dart';
import '../widgets/category_selector.dart';
import '../widgets/app_drawer.dart';
import '../widgets/number_keypad.dart';
import 'history_screen.dart';

class InputScreen extends StatefulWidget {
  const InputScreen({super.key});
  @override
  State<InputScreen> createState() => _InputScreenState();
}

class _InputScreenState extends State<InputScreen> {
  final TextEditingController _amountController = TextEditingController();
  final GlobalKey<ScaffoldState> _scaffoldKey = GlobalKey<ScaffoldState>();
  final TransactionRepository _repository = TransactionRepository();

  final SettingsRepository _settingsRepository = SettingsRepository();
  List<ShortcutItem> _shortcuts = [];

  int? _selectedExpenseIndex;
  int? _selectedPaymentIndex;
  DateTime _selectedDate = DateTime.now();
  String _currentMemo = ''; // メモの一時保存用

  @override
  void initState() {
    super.initState();
    _loadShortcuts();
    _loadDefaultPayment();
  }

  Future<void> _loadShortcuts() async {
    final items = await _settingsRepository.getActiveShortcuts();
    setState(() {
      _shortcuts = items;
    });
  }

  Future<void> _loadDefaultPayment() async {
    final defaultLabel = await _settingsRepository.loadDefaultPaymentMethod();
    if (defaultLabel != null) {
      final index = paymentTags.indexWhere((tag) => tag.label == defaultLabel);
      if (index != -1) {
        setState(() {
          _selectedPaymentIndex = index;
        });
      }
    }
  }

  Future<void> _onSettingsChanged() async {
    await _loadShortcuts();
    await _loadDefaultPayment();
  }

  @override
  void dispose() {
    _amountController.dispose();
    super.dispose();
  }

  // キーパッド入力処理
  void _onKeyPressed(String value) {
    String currentText = _amountController.text;
    if (currentText == '0') currentText = '';
    if (currentText.length >= 9) return;
    setState(() {
      _amountController.text = currentText + value;
    });
  }

  // キーパッド削除処理
  void _onDelete() {
    String currentText = _amountController.text;
    if (currentText.isNotEmpty) {
      setState(() {
        _amountController.text = currentText.substring(
          0,
          currentText.length - 1,
        );
      });
    }
  }

  // メモ入力ダイアログ
  Future<void> _showMemoDialog() async {
    final TextEditingController memoController = TextEditingController(
      text: _currentMemo,
    );
    await showDialog(
      context: context,
      builder: (context) {
        return AlertDialog(
          title: const Text('メモを入力'),
          content: TextField(
            controller: memoController,
            autofocus: true,
            decoration: const InputDecoration(hintText: '例: コンビニ、飲み会など'),
          ),
          actions: [
            TextButton(
              onPressed: () => Navigator.pop(context),
              child: const Text('キャンセル'),
            ),
            TextButton(
              onPressed: () {
                setState(() {
                  _currentMemo = memoController.text;
                });
                Navigator.pop(context);
              },
              child: const Text('OK'),
            ),
          ],
        );
      },
    );
  }

  Future<void> _pickDate() async {
    final DateTime? picked = await showDatePicker(
      context: context,
      initialDate: _selectedDate,
      firstDate: DateTime(2000),
      lastDate: DateTime(2101),
    );
    if (picked != null) setState(() => _selectedDate = picked);
  }

  Future<void> _saveData() async {
    final amountText = _amountController.text;
    if (amountText.isEmpty || amountText == "0") {
      return;
    }

    final newItem = TransactionItem(
      amount: int.tryParse(amountText) ?? 0,
      expense: _selectedExpenseIndex != null
          ? expenseTags[_selectedExpenseIndex!].label
          : 'デフォルト',
      payment: _selectedPaymentIndex != null
          ? paymentTags[_selectedPaymentIndex!].label
          : 'デフォルト',
      date: DateTime(
        _selectedDate.year,
        _selectedDate.month,
        _selectedDate.day,
        DateTime.now().hour,
        DateTime.now().minute,
      ),
      memo: _currentMemo.isEmpty ? null : _currentMemo,
    );

    await _repository.addTransaction(newItem);

    // ▼▼ 修正: 保存後、金額とメモだけクリアし、選択状態は維持する（Sticky仕様） ▼▼
    setState(() {
      _amountController.clear();
      _currentMemo = '';
      // _selectedExpenseIndex = null; // コメントアウト：選択を維持
      // _selectedPaymentIndex = null; // コメントアウト：選択を維持
    });

    if (mounted) {
      ScaffoldMessenger.of(context).showSnackBar(
        const SnackBar(
          content: Text('保存しました'),
          duration: Duration(milliseconds: 500),
        ),
      );
    }
  }

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      key: _scaffoldKey,
      drawer: AppDrawer(onSettingsChanged: _onSettingsChanged),
      body: Stack(
        children: [
          Column(
            children: [
              Expanded(
                child: SingleChildScrollView(
                  padding: const EdgeInsets.fromLTRB(20, 108, 20, 0),
                  child: Column(
                    children: [
                      _buildAmountDisplay(),
                      const SizedBox(height: 10),
                      CategorySelector(
                        tags: expenseTags,
                        selectedIndex: _selectedExpenseIndex,
                        rowCount: 2,
                        onSelected: (i) =>
                            setState(() => _selectedExpenseIndex = i),
                      ),
                      const Divider(
                        height: 20,
                        thickness: 1,
                        color: Colors.black12,
                      ),
                      CategorySelector(
                        tags: paymentTags,
                        selectedIndex: _selectedPaymentIndex,
                        rowCount: 2,
                        onSelected: (i) =>
                            setState(() => _selectedPaymentIndex = i),
                      ),
                      const SizedBox(height: 10),
                      _buildActionButtons(),
                      const SizedBox(height: 10),
                    ],
                  ),
                ),
              ),
              SizedBox(
                height: MediaQuery.of(context).size.height * 0.35,
                child: NumberKeypad(
                  onKeyPressed: _onKeyPressed,
                  onDelete: _onDelete,
                ),
              ),
            ],
          ),
          _buildHeaderButtons(),
        ],
      ),
    );
  }

  Widget _buildAmountDisplay() {
    return Row(
      crossAxisAlignment: CrossAxisAlignment.center,
      mainAxisAlignment: MainAxisAlignment.end,
      children: [
        const Text(
          '¥ ',
          style: TextStyle(
            fontSize: 44,
            color: Colors.black,
            fontWeight: FontWeight.bold,
          ),
        ),
        Expanded(
          child: Container(
            alignment: Alignment.centerRight,
            padding: const EdgeInsets.symmetric(vertical: 5),
            decoration: const BoxDecoration(
              border: Border(
                bottom: BorderSide(color: Colors.black12, width: 2),
              ),
            ),
            child: Text(
              _amountController.text.isEmpty ? '0' : _amountController.text,
              style: const TextStyle(
                fontSize: 44,
                fontWeight: FontWeight.bold,
                color: Colors.black,
              ),
            ),
          ),
        ),
        const SizedBox(width: 10),
        Padding(
          padding: const EdgeInsets.only(top: 12),
          child: IconButton(
            onPressed: _pickDate,
            icon: Column(
              mainAxisSize: MainAxisSize.min,
              children: [
                const Icon(Icons.calendar_today, size: 20, color: Colors.blue),
                const SizedBox(height: 2),
                Text(
                  "${_selectedDate.month}/${_selectedDate.day}",
                  style: const TextStyle(
                    fontSize: 11,
                    color: Colors.blue,
                    fontWeight: FontWeight.bold,
                  ),
                ),
              ],
            ),
          ),
        ),
      ],
    );
  }

  Widget _buildActionButtons() {
    final hasMemo = _currentMemo.isNotEmpty;
    return Row(
      children: [
        // ▼▼ 「次へ」を削除し、「メモ」ボタンを配置 ▼▼
        IconButton.filledTonal(
          onPressed: _showMemoDialog,
          icon: Icon(
            hasMemo ? Icons.note : Icons.note_add_outlined,
            color: hasMemo ? Colors.blue : Colors.grey,
          ),
          style: IconButton.styleFrom(
            padding: const EdgeInsets.all(16),
            backgroundColor: hasMemo
                ? Colors.blue.shade100
                : Colors.grey.shade100,
          ),
        ),
        const SizedBox(width: 10),
        // ▼▼ 保存ボタンを大きく配置 ▼▼
        Expanded(
          child: ElevatedButton(
            onPressed: () {
              _saveData();
            },
            style: ElevatedButton.styleFrom(
              padding: const EdgeInsets.symmetric(vertical: 16), // 少し高さを出す
              backgroundColor: Colors.blue,
              foregroundColor: Colors.white,
              elevation: 2,
            ),
            child: Row(
              mainAxisAlignment: MainAxisAlignment.center,
              children: [
                const Icon(Icons.check),
                const SizedBox(width: 8),
                Text(
                  '保存する',
                  style: const TextStyle(
                    fontSize: 18,
                    fontWeight: FontWeight.bold,
                  ),
                ),
                if (hasMemo) ...[
                  const SizedBox(width: 8),
                  const Text(
                    '(メモあり)',
                    style: TextStyle(
                      fontSize: 12,
                      fontWeight: FontWeight.normal,
                    ),
                  ),
                ],
              ],
            ),
          ),
        ),
      ],
    );
  }

  Widget _buildHeaderButtons() {
    final isFixedMode = _shortcuts.length <= 4;
    return Positioned(
      top: 60,
      left: 0,
      right: 0,
      height: 60,
      child: Stack(
        alignment: Alignment.centerLeft,
        children: [
          if (isFixedMode)
            Positioned(
              left: 70,
              right: 15,
              top: 0,
              bottom: 0,
              child: Row(
                mainAxisAlignment: MainAxisAlignment.spaceEvenly,
                children: _shortcuts.map((item) {
                  return _buildCircleButton(
                    icon: item.icon,
                    color: item.color,
                    onTap: () => _navigateToHistory(item),
                  );
                }).toList(),
              ),
            )
          else
            Positioned.fill(
              child: Stack(
                children: [
                  ListView.builder(
                    scrollDirection: Axis.horizontal,
                    padding: const EdgeInsets.only(left: 70, right: 20),
                    physics: const BouncingScrollPhysics(),
                    itemCount: _shortcuts.length,
                    itemBuilder: (context, index) {
                      final item = _shortcuts[index];
                      return Padding(
                        padding: const EdgeInsets.only(right: 12),
                        child: _buildCircleButton(
                          icon: item.icon,
                          color: item.color,
                          onTap: () => _navigateToHistory(item),
                        ),
                      );
                    },
                  ),
                  Positioned(
                    left: 0,
                    width: 80,
                    top: 0,
                    bottom: 0,
                    child: Container(
                      decoration: BoxDecoration(
                        gradient: LinearGradient(
                          colors: [
                            Colors.white.withOpacity(1.0),
                            Colors.white.withOpacity(0.0),
                          ],
                          begin: Alignment.centerLeft,
                          end: Alignment.centerRight,
                          stops: const [0.6, 1.0],
                        ),
                      ),
                    ),
                  ),
                ],
              ),
            ),
          Positioned(
            left: 15,
            child: _buildCircleButton(
              icon: Icons.menu,
              color: Colors.blue,
              onTap: () => _scaffoldKey.currentState?.openDrawer(),
            ),
          ),
        ],
      ),
    );
  }

  void _navigateToHistory(ShortcutItem item) {
    Navigator.push(
      context,
      MaterialPageRoute(
        builder: (context) => HistoryScreen(
          filterValue: item.label,
          filterKey: item.key,
          color: item.color,
        ),
      ),
    );
  }

  Widget _buildCircleButton({
    required IconData icon,
    required Color color,
    required VoidCallback onTap,
  }) {
    return Container(
      decoration: const BoxDecoration(
        color: Colors.white,
        shape: BoxShape.circle,
        boxShadow: [
          BoxShadow(color: Colors.black12, blurRadius: 5, offset: Offset(0, 2)),
        ],
      ),
      child: IconButton(
        icon: Icon(icon, color: color, size: 24),
        onPressed: onTap,
        constraints: const BoxConstraints(minWidth: 45, minHeight: 45),
        style: IconButton.styleFrom(padding: const EdgeInsets.all(8)),
      ),
    );
  }
}

```


--- FILE: lib/screens/monthly_report_screen.dart ---
```dart
import 'package:flutter/material.dart';
import '../models/category_tag.dart';
import '../models/transaction_item.dart';
import '../repositories/transaction_repository.dart';

class MonthlyHistoryScreen extends StatefulWidget {
  const MonthlyHistoryScreen({super.key});
  @override
  State<MonthlyHistoryScreen> createState() => _MonthlyHistoryScreenState();
}

class _MonthlyHistoryScreenState extends State<MonthlyHistoryScreen> {
  // 初期位置を現在の月に設定 (1000ヶ月目を現在とする)
  final PageController _pageController = PageController(initialPage: 1000);

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      appBar: AppBar(title: const Text('月別レポート')),
      body: PageView.builder(
        controller: _pageController,
        itemBuilder: (context, index) {
          final d = DateTime(
            DateTime.now().year,
            DateTime.now().month + (index - 1000),
          );
          return MonthPage(year: d.year, month: d.month);
        },
      ),
    );
  }
}

class MonthPage extends StatefulWidget {
  final int year;
  final int month;
  const MonthPage({super.key, required this.year, required this.month});
  @override
  State<MonthPage> createState() => _MonthPageState();
}

class _MonthPageState extends State<MonthPage> {
  List<TransactionItem> _history = [];
  final TransactionRepository _repository = TransactionRepository();

  // 追加: 表示モードの切り替え（0:履歴, 1:分析）
  int _viewMode = 0;

  @override
  void initState() {
    super.initState();
    _load();
  }

  Future<void> _load() async {
    final allItems = await _repository.getAllTransactions();
    setState(() {
      _history = allItems.where((i) {
        return i.date.year == widget.year && i.date.month == widget.month;
      }).toList();
    });
  }

  @override
  Widget build(BuildContext context) {
    int total = _history.fold(0, (s, i) => s + i.amount);

    return Column(
      children: [
        // ヘッダー（年月表示）
        Padding(
          padding: const EdgeInsets.all(10),
          child: Text(
            "${widget.year}年 ${widget.month}月",
            style: const TextStyle(fontSize: 20, fontWeight: FontWeight.bold),
          ),
        ),

        // 合計金額カード
        _buildSummaryCard(total),

        // 表示切り替えスイッチ
        Container(
          margin: const EdgeInsets.symmetric(horizontal: 20, vertical: 5),
          decoration: BoxDecoration(
            color: Colors.grey.shade200,
            borderRadius: BorderRadius.circular(10),
          ),
          child: Row(
            children: [
              _buildSwitchButton('履歴', 0),
              _buildSwitchButton('分析', 1),
            ],
          ),
        ),
        const SizedBox(height: 10),

        // コンテンツ部分（履歴リスト or 分析グラフ）
        Expanded(
          child: _viewMode == 0
              ? _buildHistoryList()
              : _buildAnalysisView(total),
        ),
      ],
    );
  }

  Widget _buildSwitchButton(String label, int index) {
    final isSelected = _viewMode == index;
    return Expanded(
      child: GestureDetector(
        onTap: () => setState(() => _viewMode = index),
        child: Container(
          padding: const EdgeInsets.symmetric(vertical: 10),
          decoration: BoxDecoration(
            color: isSelected ? Colors.white : Colors.transparent,
            borderRadius: BorderRadius.circular(8),
            boxShadow: isSelected
                ? [const BoxShadow(color: Colors.black12, blurRadius: 2)]
                : null,
          ),
          child: Center(
            child: Text(
              label,
              style: TextStyle(
                fontWeight: FontWeight.bold,
                color: isSelected ? Colors.blue : Colors.grey,
              ),
            ),
          ),
        ),
      ),
    );
  }

  // 元の履歴リスト
  Widget _buildHistoryList() {
    if (_history.isEmpty) {
      return const Center(
        child: Text('データがありません', style: TextStyle(color: Colors.grey)),
      );
    }
    return ListView.builder(
      itemCount: _history.length,
      itemBuilder: (c, i) {
        final item = _history[i];
        final expenseStr = item.expense == 'デフォルト' ? '' : ' (${item.expense})';
        final paymentStr = item.payment == 'デフォルト' ? '' : '${item.payment} / ';
        return ListTile(
          title: Text('¥${item.amount}$expenseStr'),
          subtitle: Text('$paymentStr${item.displayDate}'),
        );
      },
    );
  }

  // 新規追加: 分析ビュー
  Widget _buildAnalysisView(int totalAmount) {
    if (totalAmount == 0) {
      return const Center(
        child: Text('データがありません', style: TextStyle(color: Colors.grey)),
      );
    }

    return SingleChildScrollView(
      padding: const EdgeInsets.symmetric(horizontal: 20, vertical: 10),
      child: Column(
        crossAxisAlignment: CrossAxisAlignment.start,
        children: [
          const Text(
            '費目別',
            style: TextStyle(fontWeight: FontWeight.bold, fontSize: 16),
          ),
          const SizedBox(height: 10),
          ..._buildRankList(isExpense: true, total: totalAmount),

          const Divider(height: 40),

          const Text(
            '支払い方法別',
            style: TextStyle(fontWeight: FontWeight.bold, fontSize: 16),
          ),
          const SizedBox(height: 10),
          ..._buildRankList(isExpense: false, total: totalAmount),
          const SizedBox(height: 30),
        ],
      ),
    );
  }

  List<Widget> _buildRankList({required bool isExpense, required int total}) {
    // 集計処理
    Map<String, int> sums = {};
    for (var item in _history) {
      final key = isExpense ? item.expense : item.payment;
      sums[key] = (sums[key] ?? 0) + item.amount;
    }

    // 金額順にソート
    final sortedKeys = sums.keys.toList()
      ..sort((a, b) => sums[b]!.compareTo(sums[a]!));

    // カテゴリ定義を取得（色などのため）
    final tags = isExpense ? expenseTags : paymentTags;

    return sortedKeys.map((key) {
      final amount = sums[key]!;
      final percent = (amount / total);

      // 色を探す（デフォルトの場合はグレー）
      Color color = Colors.grey;
      try {
        if (key != 'デフォルト') {
          color = tags.firstWhere((t) => t.label == key).color;
        }
      } catch (_) {}

      return Padding(
        padding: const EdgeInsets.only(bottom: 12),
        child: Column(
          children: [
            Row(
              mainAxisAlignment: MainAxisAlignment.spaceBetween,
              children: [
                Row(
                  children: [
                    Container(
                      width: 12,
                      height: 12,
                      decoration: BoxDecoration(
                        color: color,
                        shape: BoxShape.circle,
                      ),
                    ),
                    const SizedBox(width: 8),
                    Text(
                      key,
                      style: const TextStyle(fontWeight: FontWeight.bold),
                    ),
                  ],
                ),
                Text('¥$amount'),
              ],
            ),
            const SizedBox(height: 4),
            ClipRRect(
              borderRadius: BorderRadius.circular(4),
              child: LinearProgressIndicator(
                value: percent,
                backgroundColor: Colors.grey.shade200,
                color: color,
                minHeight: 8,
              ),
            ),
          ],
        ),
      );
    }).toList();
  }

  Widget _buildSummaryCard(int total) {
    return Card(
      margin: const EdgeInsets.all(15),
      color: Colors.blue.shade50,
      elevation: 0,
      child: Container(
        width: double.infinity,
        padding: const EdgeInsets.all(20),
        child: Column(
          children: [
            const Text('総支出', style: TextStyle(color: Colors.blueGrey)),
            Text(
              '¥ $total',
              style: const TextStyle(
                fontSize: 32,
                fontWeight: FontWeight.bold,
                color: Colors.blue,
              ),
            ),
          ],
        ),
      ),
    );
  }
}

```


--- FILE: lib/widgets/category_selector.dart ---
```dart
import 'package:flutter/material.dart';
import '../models/category_tag.dart';

class CategorySelector extends StatelessWidget {
  final List<CategoryTag> tags;
  final int? selectedIndex;
  final int rowCount;
  final Function(int) onSelected;

  const CategorySelector({
    super.key,
    required this.tags,
    required this.selectedIndex,
    required this.rowCount,
    required this.onSelected,
  });

  @override
  Widget build(BuildContext context) {
    return SizedBox(
      height: rowCount == 2 ? 100 : 50,
      child: GridView.builder(
        scrollDirection: Axis.horizontal,
        gridDelegate: SliverGridDelegateWithFixedCrossAxisCount(
          crossAxisCount: rowCount,
          mainAxisSpacing: 6,
          crossAxisSpacing: 6,
          childAspectRatio: rowCount == 2 ? 0.45 : 0.4,
        ),
        itemCount: tags.length,
        itemBuilder: (context, index) {
          final tag = tags[index];
          final isSelected = selectedIndex == index;
          return ChoiceChip(
            label: Text(tag.label, style: const TextStyle(fontSize: 12)),
            selected: isSelected,
            onSelected: (_) => onSelected(index),
            shape: tag.isCircle
                ? const StadiumBorder()
                : RoundedRectangleBorder(
                    borderRadius: BorderRadius.circular(8),
                  ),
            selectedColor: tag.color.withOpacity(0.3),
            visualDensity: VisualDensity.compact,
          );
        },
      ),
    );
  }
}

```


--- FILE: lib/widgets/app_drawer.dart ---
```dart
import 'package:flutter/material.dart';
import '../models/category_tag.dart';
import '../screens/monthly_report_screen.dart';
import '../screens/history_screen.dart';
import '../screens/settings_screen.dart'; // 設定画面

class AppDrawer extends StatelessWidget {
  // 設定変更時にInputScreenを更新するためのコールバック
  final VoidCallback? onSettingsChanged;

  const AppDrawer({super.key, this.onSettingsChanged});

  @override
  Widget build(BuildContext context) {
    return Drawer(
      child: Column(
        // Columnに変更してSpacerを使えるようにする
        children: [
          Expanded(
            child: ListView(
              padding: EdgeInsets.zero,
              children: [
                const DrawerHeader(
                  decoration: BoxDecoration(color: Colors.blue),
                  child: Text(
                    'メニュー',
                    style: TextStyle(color: Colors.white, fontSize: 24),
                  ),
                ),
                ListTile(
                  leading: const Icon(Icons.calendar_month),
                  title: const Text('月別レポート'),
                  onTap: () {
                    Navigator.pop(context);
                    Navigator.push(
                      context,
                      MaterialPageRoute(
                        builder: (context) => const MonthlyHistoryScreen(),
                      ),
                    );
                  },
                ),
                const Divider(),
                _buildSectionHeader("費目別"),
                _buildFilterTile(
                  context,
                  const CategoryTag('デフォルト', Colors.blueGrey),
                  'expense',
                ),
                ...expenseTags.map(
                  (tag) => _buildFilterTile(context, tag, 'expense'),
                ),
                const SizedBox(height: 15),
                const Divider(),
                _buildSectionHeader("支払い方法別"),
                _buildFilterTile(
                  context,
                  const CategoryTag('デフォルト', Colors.grey),
                  'payment',
                ),
                ...paymentTags.map(
                  (tag) => _buildFilterTile(context, tag, 'payment'),
                ),
              ],
            ),
          ),
          const Divider(),
          // ▼▼ 設定ボタン（最下部） ▼▼
          ListTile(
            leading: const Icon(Icons.settings, color: Colors.grey),
            title: const Text('設定'),
            onTap: () async {
              // ドロワーを閉じる
              Navigator.pop(context);
              // 設定画面へ遷移し、戻ってくるのを待つ
              await Navigator.push(
                context,
                MaterialPageRoute(builder: (context) => const SettingsScreen()),
              );
              // 戻ってきたらコールバックを実行（InputScreenを更新）
              onSettingsChanged?.call();
            },
          ),
          const SizedBox(height: 20), // 下部の余白
        ],
      ),
    );
  }

  Widget _buildSectionHeader(String title) {
    return Padding(
      padding: const EdgeInsets.only(left: 16, top: 10, bottom: 5),
      child: Text(
        title,
        style: const TextStyle(color: Colors.grey, fontSize: 12),
      ),
    );
  }

  Widget _buildFilterTile(
    BuildContext context,
    CategoryTag tag,
    String filterKey,
  ) {
    return ListTile(
      leading: Icon(
        filterKey == 'payment' ? Icons.payment : Icons.label,
        color: tag.color,
      ),
      title: Text(tag.label),
      onTap: () {
        Navigator.pop(context);
        Navigator.push(
          context,
          MaterialPageRoute(
            builder: (context) => HistoryScreen(
              filterValue: tag.label,
              filterKey: filterKey,
              color: tag.color,
            ),
          ),
        );
      },
    );
  }
}

```


--- FILE: lib/widgets/number_keypad.dart ---
```dart
import 'package:flutter/material.dart';

class NumberKeypad extends StatelessWidget {
  final Function(String) onKeyPressed;
  final VoidCallback onDelete;

  const NumberKeypad({
    super.key,
    required this.onKeyPressed,
    required this.onDelete,
  });

  @override
  Widget build(BuildContext context) {
    return Container(
      color: Colors.white,
      padding: const EdgeInsets.fromLTRB(10, 0, 10, 20), // 下に余白
      child: Column(
        mainAxisSize: MainAxisSize.min,
        children: [
          _buildRow(['7', '8', '9']),
          _buildRow(['4', '5', '6']),
          _buildRow(['1', '2', '3']),
          _buildRow(['00', '0', 'DEL']),
        ],
      ),
    );
  }

  Widget _buildRow(List<String> keys) {
    return Expanded(
      child: Row(
        children: keys.map((key) {
          return Expanded(
            child: Padding(
              padding: const EdgeInsets.all(4.0), // ボタン間の隙間
              child: _buildButton(key),
            ),
          );
        }).toList(),
      ),
    );
  }

  Widget _buildButton(String key) {
    final isDelete = key == 'DEL';

    return Material(
      color: isDelete ? Colors.red.shade50 : Colors.grey.shade50,
      borderRadius: BorderRadius.circular(8),
      child: InkWell(
        borderRadius: BorderRadius.circular(8),
        onTap: () {
          if (isDelete) {
            onDelete();
          } else {
            onKeyPressed(key);
          }
        },
        child: Center(
          child: isDelete
              ? const Icon(Icons.backspace_outlined, color: Colors.redAccent)
              : Text(
                  key,
                  style: const TextStyle(
                    fontSize: 24,
                    fontWeight: FontWeight.bold,
                    color: Colors.black87,
                  ),
                ),
        ),
      ),
    );
  }
}

```

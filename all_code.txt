

--- FILE: main.dart ---
```dart
import 'package:flutter/material.dart';
import 'screens/input_screen.dart';

void main() {
  runApp(const QuickKakeiboApp());
}

class QuickKakeiboApp extends StatelessWidget {
  const QuickKakeiboApp({super.key});
  @override
  Widget build(BuildContext context) {
    return MaterialApp(
      debugShowCheckedModeBanner: false,
      title: 'Quick Kakeibo',
      theme: ThemeData(useMaterial3: true, colorSchemeSeed: Colors.blue),
      home: const InputScreen(),
    );
  }
}

```


--- FILE: pubspec.yaml ---
```
name: flutter_application_1
description: "A new Flutter project."
# The following line prevents the package from being accidentally published to
# pub.dev using `flutter pub publish`. This is preferred for private packages.
publish_to: 'none' # Remove this line if you wish to publish to pub.dev

# The following defines the version and build number for your application.
# A version number is three numbers separated by dots, like 1.2.43
# followed by an optional build number separated by a +.
# Both the version and the builder number may be overridden in flutter
# build by specifying --build-name and --build-number, respectively.
# In Android, build-name is used as versionName while build-number used as versionCode.
# Read more about Android versioning at https://developer.android.com/studio/publish/versioning
# In iOS, build-name is used as CFBundleShortVersionString while build-number is used as CFBundleVersion.
# Read more about iOS versioning at
# https://developer.apple.com/library/archive/documentation/General/Reference/InfoPlistKeyReference/Articles/CoreFoundationKeys.html
# In Windows, build-name is used as the major, minor, and patch parts
# of the product and file versions while build-number is used as the build suffix.
version: 1.0.0+1

environment:
  sdk: ^3.9.2

# Dependencies specify other packages that your package needs in order to work.
# To automatically upgrade your package dependencies to the latest versions
# consider running `flutter pub upgrade --major-versions`. Alternatively,
# dependencies can be manually updated by changing the version numbers below to
# the latest version available on pub.dev. To see which dependencies have newer
# versions available, run `flutter pub outdated`.
dependencies:
  flutter:
    sdk: flutter

  # The following adds the Cupertino Icons font to your application.
  # Use with the CupertinoIcons class for iOS style icons.
  cupertino_icons: ^1.0.8
  shared_preferences: ^2.5.4

  # 新規追加: ゲームエンジンとフォント
  flame: ^1.20.0
  google_fonts: ^6.1.0

dev_dependencies:
  flutter_test:
    sdk: flutter

  # The "flutter_lints" package below contains a set of recommended lints to
  # encourage good coding practices. The lint set provided by the package is
  # activated in the `analysis_options.yaml` file located at the root of your
  # package. See that file for information about deactivating specific lint
  # rules and activating additional ones.
  flutter_lints: ^5.0.0

# For information on the generic Dart part of this file, see the
# following page: https://dart.dev/tools/pub/pubspec

# The following section is specific to Flutter packages.
flutter:

  # The following line ensures that the Material Icons font is
  # included with your application, so that you can use the icons in
  # the material Icons class.
  uses-material-design: true

  # To add assets to your application, add an assets section, like this:
  # assets:
  #   - images/a_dot_burr.jpeg
  #   - images/a_dot_ham.jpeg

  # An image asset can refer to one or more resolution-specific "variants", see
  # https://flutter.dev/to/resolution-aware-images

  # For details regarding adding assets from package dependencies, see
  # https://flutter.dev/to/asset-from-package

  # To add custom fonts to your application, add a fonts section here,
  # in this "flutter" section. Each entry in this list should have a
  # "family" key with the font family name, and a "fonts" key with a
  # list giving the asset and other descriptors for the font. For
  # example:
  # fonts:
  #   - family: Schyler
  #     fonts:
  #       - asset: fonts/Schyler-Regular.ttf
  #       - asset: fonts/Schyler-Italic.ttf
  #         style: italic
  #   - family: Trajan Pro
  #     fonts:
  #       - asset: fonts/TrajanPro.ttf
  #       - asset: fonts/TrajanPro_Bold.ttf
  #         weight: 700
  #
  # For details regarding fonts from package dependencies,
  # see https://flutter.dev/to/font-from-package

```


--- FILE: analysis_options.yaml ---
```
# This file configures the analyzer, which statically analyzes Dart code to
# check for errors, warnings, and lints.
#
# The issues identified by the analyzer are surfaced in the UI of Dart-enabled
# IDEs (https://dart.dev/tools#ides-and-editors). The analyzer can also be
# invoked from the command line by running `flutter analyze`.

# The following line activates a set of recommended lints for Flutter apps,
# packages, and plugins designed to encourage good coding practices.
include: package:flutter_lints/flutter.yaml

linter:
  # The lint rules applied to this project can be customized in the
  # section below to disable rules from the `package:flutter_lints/flutter.yaml`
  # included above or to enable additional rules. A list of all available lints
  # and their documentation is published at https://dart.dev/lints.
  #
  # Instead of disabling a lint rule for the entire project in the
  # section below, it can also be suppressed for a single line of code
  # or a specific dart file by using the `// ignore: name_of_lint` and
  # `// ignore_for_file: name_of_lint` syntax on the line or in the file
  # producing the lint.
  rules:
    # avoid_print: false  # Uncomment to disable the `avoid_print` rule
    # prefer_single_quotes: true  # Uncomment to enable the `prefer_single_quotes` rule

# Additional information about this file can be found at
# https://dart.dev/guides/language/analysis-options

```


--- FILE: test/widget_test.dart ---
```dart
// This is a basic Flutter widget test.
//
// To perform an interaction with a widget in your test, use the WidgetTester
// utility in the flutter_test package. For example, you can send tap and scroll
// gestures. You can also use WidgetTester to find child widgets in the widget
// tree, read text, and verify that the values of widget properties are correct.

import 'package:flutter/material.dart';
import 'package:flutter_test/flutter_test.dart';

import 'package:flutter_application_1/main.dart';

void main() {
  testWidgets('Counter increments smoke test', (WidgetTester tester) async {
    // Build our app and trigger a frame.
    await tester.pumpWidget(const MyApp());

    // Verify that our counter starts at 0.
    expect(find.text('0'), findsOneWidget);
    expect(find.text('1'), findsNothing);

    // Tap the '+' icon and trigger a frame.
    await tester.tap(find.byIcon(Icons.add));
    await tester.pump();

    // Verify that our counter has incremented.
    expect(find.text('0'), findsNothing);
    expect(find.text('1'), findsOneWidget);
  });
}

```


--- FILE: web/manifest.json ---
```
{
    "name": "flutter_application_1",
    "short_name": "flutter_application_1",
    "start_url": ".",
    "display": "standalone",
    "background_color": "#0175C2",
    "theme_color": "#0175C2",
    "description": "A new Flutter project.",
    "orientation": "portrait-primary",
    "prefer_related_applications": false,
    "icons": [
        {
            "src": "icons/Icon-192.png",
            "sizes": "192x192",
            "type": "image/png"
        },
        {
            "src": "icons/Icon-512.png",
            "sizes": "512x512",
            "type": "image/png"
        },
        {
            "src": "icons/Icon-maskable-192.png",
            "sizes": "192x192",
            "type": "image/png",
            "purpose": "maskable"
        },
        {
            "src": "icons/Icon-maskable-512.png",
            "sizes": "512x512",
            "type": "image/png",
            "purpose": "maskable"
        }
    ]
}

```


--- FILE: flutter_project/main.dart ---
```dart
import 'package:flutter/material.dart';
import 'screens/input_screen.dart';

void main() {
  runApp(const QuickKakeiboApp());
}

class QuickKakeiboApp extends StatelessWidget {
  const QuickKakeiboApp({super.key});
  @override
  Widget build(BuildContext context) {
    return MaterialApp(
      debugShowCheckedModeBanner: false,
      title: 'Quick Kakeibo',
      theme: ThemeData(useMaterial3: true, colorSchemeSeed: Colors.blue),
      home: const InputScreen(),
    );
  }
}

```


--- FILE: flutter_project/pubspec.yaml ---
```
name: flutter_application_1
description: "A new Flutter project."
# The following line prevents the package from being accidentally published to
# pub.dev using `flutter pub publish`. This is preferred for private packages.
publish_to: 'none' # Remove this line if you wish to publish to pub.dev

# The following defines the version and build number for your application.
# A version number is three numbers separated by dots, like 1.2.43
# followed by an optional build number separated by a +.
# Both the version and the builder number may be overridden in flutter
# build by specifying --build-name and --build-number, respectively.
# In Android, build-name is used as versionName while build-number used as versionCode.
# Read more about Android versioning at https://developer.android.com/studio/publish/versioning
# In iOS, build-name is used as CFBundleShortVersionString while build-number is used as CFBundleVersion.
# Read more about iOS versioning at
# https://developer.apple.com/library/archive/documentation/General/Reference/InfoPlistKeyReference/Articles/CoreFoundationKeys.html
# In Windows, build-name is used as the major, minor, and patch parts
# of the product and file versions while build-number is used as the build suffix.
version: 1.0.0+1

environment:
  sdk: ^3.9.2

# Dependencies specify other packages that your package needs in order to work.
# To automatically upgrade your package dependencies to the latest versions
# consider running `flutter pub upgrade --major-versions`. Alternatively,
# dependencies can be manually updated by changing the version numbers below to
# the latest version available on pub.dev. To see which dependencies have newer
# versions available, run `flutter pub outdated`.
dependencies:
  flutter:
    sdk: flutter

  # The following adds the Cupertino Icons font to your application.
  # Use with the CupertinoIcons class for iOS style icons.
  cupertino_icons: ^1.0.8
  shared_preferences: ^2.5.4

dev_dependencies:
  flutter_test:
    sdk: flutter

  # The "flutter_lints" package below contains a set of recommended lints to
  # encourage good coding practices. The lint set provided by the package is
  # activated in the `analysis_options.yaml` file located at the root of your
  # package. See that file for information about deactivating specific lint
  # rules and activating additional ones.
  flutter_lints: ^5.0.0

# For information on the generic Dart part of this file, see the
# following page: https://dart.dev/tools/pub/pubspec

# The following section is specific to Flutter packages.
flutter:

  # The following line ensures that the Material Icons font is
  # included with your application, so that you can use the icons in
  # the material Icons class.
  uses-material-design: true

  # To add assets to your application, add an assets section, like this:
  # assets:
  #   - images/a_dot_burr.jpeg
  #   - images/a_dot_ham.jpeg

  # An image asset can refer to one or more resolution-specific "variants", see
  # https://flutter.dev/to/resolution-aware-images

  # For details regarding adding assets from package dependencies, see
  # https://flutter.dev/to/asset-from-package

  # To add custom fonts to your application, add a fonts section here,
  # in this "flutter" section. Each entry in this list should have a
  # "family" key with the font family name, and a "fonts" key with a
  # list giving the asset and other descriptors for the font. For
  # example:
  # fonts:
  #   - family: Schyler
  #     fonts:
  #       - asset: fonts/Schyler-Regular.ttf
  #       - asset: fonts/Schyler-Italic.ttf
  #         style: italic
  #   - family: Trajan Pro
  #     fonts:
  #       - asset: fonts/TrajanPro.ttf
  #       - asset: fonts/TrajanPro_Bold.ttf
  #         weight: 700
  #
  # For details regarding fonts from package dependencies,
  # see https://flutter.dev/to/font-from-package

```


--- FILE: flutter_project/analysis_options.yaml ---
```
# This file configures the analyzer, which statically analyzes Dart code to
# check for errors, warnings, and lints.
#
# The issues identified by the analyzer are surfaced in the UI of Dart-enabled
# IDEs (https://dart.dev/tools#ides-and-editors). The analyzer can also be
# invoked from the command line by running `flutter analyze`.

# The following line activates a set of recommended lints for Flutter apps,
# packages, and plugins designed to encourage good coding practices.
include: package:flutter_lints/flutter.yaml

linter:
  # The lint rules applied to this project can be customized in the
  # section below to disable rules from the `package:flutter_lints/flutter.yaml`
  # included above or to enable additional rules. A list of all available lints
  # and their documentation is published at https://dart.dev/lints.
  #
  # Instead of disabling a lint rule for the entire project in the
  # section below, it can also be suppressed for a single line of code
  # or a specific dart file by using the `// ignore: name_of_lint` and
  # `// ignore_for_file: name_of_lint` syntax on the line or in the file
  # producing the lint.
  rules:
    # avoid_print: false  # Uncomment to disable the `avoid_print` rule
    # prefer_single_quotes: true  # Uncomment to enable the `prefer_single_quotes` rule

# Additional information about this file can be found at
# https://dart.dev/guides/language/analysis-options

```


--- FILE: flutter_project/test/widget_test.dart ---
```dart
// This is a basic Flutter widget test.
//
// To perform an interaction with a widget in your test, use the WidgetTester
// utility in the flutter_test package. For example, you can send tap and scroll
// gestures. You can also use WidgetTester to find child widgets in the widget
// tree, read text, and verify that the values of widget properties are correct.

import 'package:flutter/material.dart';
import 'package:flutter_test/flutter_test.dart';

import 'package:flutter_application_1/main.dart';

void main() {
  testWidgets('Counter increments smoke test', (WidgetTester tester) async {
    // Build our app and trigger a frame.
    await tester.pumpWidget(const MyApp());

    // Verify that our counter starts at 0.
    expect(find.text('0'), findsOneWidget);
    expect(find.text('1'), findsNothing);

    // Tap the '+' icon and trigger a frame.
    await tester.tap(find.byIcon(Icons.add));
    await tester.pump();

    // Verify that our counter has incremented.
    expect(find.text('0'), findsNothing);
    expect(find.text('1'), findsOneWidget);
  });
}

```


--- FILE: flutter_project/web/manifest.json ---
```
{
    "name": "flutter_application_1",
    "short_name": "flutter_application_1",
    "start_url": ".",
    "display": "standalone",
    "background_color": "#0175C2",
    "theme_color": "#0175C2",
    "description": "A new Flutter project.",
    "orientation": "portrait-primary",
    "prefer_related_applications": false,
    "icons": [
        {
            "src": "icons/Icon-192.png",
            "sizes": "192x192",
            "type": "image/png"
        },
        {
            "src": "icons/Icon-512.png",
            "sizes": "512x512",
            "type": "image/png"
        },
        {
            "src": "icons/Icon-maskable-192.png",
            "sizes": "192x192",
            "type": "image/png",
            "purpose": "maskable"
        },
        {
            "src": "icons/Icon-maskable-512.png",
            "sizes": "512x512",
            "type": "image/png",
            "purpose": "maskable"
        }
    ]
}

```


--- FILE: flutter_project/lib/main.dart ---
```dart
import 'package:flutter/material.dart';
import 'screens/input_screen.dart';

void main() {
  runApp(const QuickKakeiboApp());
}

class QuickKakeiboApp extends StatelessWidget {
  const QuickKakeiboApp({super.key});
  @override
  Widget build(BuildContext context) {
    return MaterialApp(
      debugShowCheckedModeBanner: false,
      title: 'Quick Kakeibo',
      theme: ThemeData(useMaterial3: true, colorSchemeSeed: Colors.blue),
      home: const InputScreen(),
    );
  }
}

```


--- FILE: flutter_project/lib/repositories/transaction_repository.dart ---
```dart
import 'dart:convert';
import 'package:shared_preferences/shared_preferences.dart';
import '../models/transaction_item.dart';

class TransactionRepository {
  static const String _key = 'history';

  // 保存処理
  Future<void> addTransaction(TransactionItem item) async {
    final prefs = await SharedPreferences.getInstance();
    final List<TransactionItem> currentList = await getAllTransactions();

    // 新しいデータを先頭に追加
    currentList.insert(0, item);

    // JSON文字列に変換して保存
    final String jsonString = json.encode(
      currentList.map((e) => e.toJson()).toList(),
    );
    await prefs.setString(_key, jsonString);
  }

  // 全件取得処理
  Future<List<TransactionItem>> getAllTransactions() async {
    final prefs = await SharedPreferences.getInstance();
    final String? jsonString = prefs.getString(_key);

    if (jsonString == null) return [];

    final List<dynamic> jsonList = json.decode(jsonString);
    return jsonList.map((e) => TransactionItem.fromJson(e)).toList();
  }
}

```


--- FILE: flutter_project/lib/models/transaction_item.dart ---
```dart
class TransactionItem {
  final int amount;
  final String expense;
  final String payment;
  final DateTime date;

  TransactionItem({
    required this.amount,
    required this.expense,
    required this.payment,
    required this.date,
  });

  // 表示用日付フォーマット
  String get displayDate {
    return "${date.month}/${date.day} ${date.hour}:${date.minute.toString().padLeft(2, '0')}";
  }

  // JSON保存用: Mapに変換
  Map<String, dynamic> toJson() {
    return {
      'amount': amount,
      'expense': expense,
      'payment': payment,
      'date_iso': date.toIso8601String(),
    };
  }

  // 読み込み用: Mapから生成
  factory TransactionItem.fromJson(Map<String, dynamic> json) {
    return TransactionItem(
      amount: json['amount'] as int,
      expense: json['expense'] as String,
      payment: json['payment'] as String,
      date: DateTime.parse(json['date_iso'] as String),
    );
  }
}

```


--- FILE: flutter_project/lib/models/category_tag.dart ---
```dart
import 'package:flutter/material.dart';

class CategoryTag {
  final String label;
  final Color color;
  final bool isCircle;

  const CategoryTag(this.label, this.color, {this.isCircle = false});
}

// 定数データ
final List<CategoryTag> expenseTags = [
  CategoryTag('食費', Colors.orange, isCircle: true),
  CategoryTag('日用品', Colors.green, isCircle: true),
  CategoryTag('雑費', Colors.blueGrey, isCircle: true),
  CategoryTag('交際費', Colors.pink, isCircle: true),
  CategoryTag('趣味', Colors.purple, isCircle: true),
];

final List<CategoryTag> paymentTags = [
  CategoryTag('現金', Colors.grey),
  CategoryTag('クレカ', Colors.blue),
  CategoryTag('PayPay', Colors.redAccent),
  CategoryTag('Suica', Colors.lightGreen),
];

```


--- FILE: flutter_project/lib/screens/history_screen.dart ---
```dart
import 'package:flutter/material.dart';
import '../models/transaction_item.dart';
import '../repositories/transaction_repository.dart';

class HistoryScreen extends StatefulWidget {
  final String filterValue;
  final String filterKey; // 'expense' or 'payment'
  final Color? color;

  const HistoryScreen({
    super.key,
    required this.filterValue,
    required this.filterKey,
    this.color,
  });

  @override
  State<HistoryScreen> createState() => _HistoryScreenState();
}

class _HistoryScreenState extends State<HistoryScreen> {
  List<TransactionItem> _history = [];
  final TransactionRepository _repository = TransactionRepository();

  @override
  void initState() {
    super.initState();
    _load();
  }

  Future<void> _load() async {
    final allItems = await _repository.getAllTransactions();
    setState(() {
      _history = allItems.where((i) {
        if (widget.filterKey == 'expense')
          return i.expense == widget.filterValue;
        if (widget.filterKey == 'payment')
          return i.payment == widget.filterValue;
        return false;
      }).toList();
    });
  }

  @override
  Widget build(BuildContext context) {
    int total = _history.fold(0, (s, i) => s + i.amount);
    return Scaffold(
      appBar: AppBar(title: Text(widget.filterValue)),
      body: Column(
        children: [
          Container(
            width: double.infinity,
            padding: const EdgeInsets.all(20),
            color: widget.color?.withOpacity(0.1) ?? Colors.blue.shade50,
            child: Center(
              child: Column(
                children: [
                  Text(
                    widget.filterKey == 'expense' ? '費目累計' : '支払い累計',
                    style: const TextStyle(fontSize: 14, color: Colors.grey),
                  ),
                  Text(
                    '¥ $total',
                    style: TextStyle(
                      fontSize: 28,
                      fontWeight: FontWeight.bold,
                      color: widget.color ?? Colors.black,
                    ),
                  ),
                ],
              ),
            ),
          ),
          Expanded(
            child: ListView.builder(
              itemCount: _history.length,
              itemBuilder: (c, i) => ListTile(
                leading: Icon(
                  widget.filterKey == 'payment' ? Icons.payment : Icons.label,
                  color: widget.color,
                ),
                title: Text(
                  '¥${_history[i].amount}',
                  style: const TextStyle(fontWeight: FontWeight.bold),
                ),
                subtitle: Text(
                  "${_history[i].displayDate}  /  ${widget.filterKey == 'expense' ? _history[i].payment : _history[i].expense}",
                ),
              ),
            ),
          ),
        ],
      ),
    );
  }
}

```


--- FILE: flutter_project/lib/screens/input_screen.dart ---
```dart
import 'package:flutter/material.dart';
import '../models/category_tag.dart';
import '../models/transaction_item.dart';
import '../repositories/transaction_repository.dart';
import '../widgets/category_selector.dart';
import '../widgets/app_drawer.dart';

class InputScreen extends StatefulWidget {
  const InputScreen({super.key});
  @override
  State<InputScreen> createState() => _InputScreenState();
}

class _InputScreenState extends State<InputScreen> {
  final TextEditingController _amountController = TextEditingController();
  final FocusNode _amountFocusNode = FocusNode();
  final GlobalKey<ScaffoldState> _scaffoldKey = GlobalKey<ScaffoldState>();
  final TransactionRepository _repository = TransactionRepository();

  int? _selectedExpenseIndex;
  int? _selectedPaymentIndex;
  DateTime _selectedDate = DateTime.now();

  @override
  void dispose() {
    _amountFocusNode.dispose();
    _amountController.dispose();
    super.dispose();
  }

  Future<void> _pickDate() async {
    final DateTime? picked = await showDatePicker(
      context: context,
      initialDate: _selectedDate,
      firstDate: DateTime(2000),
      lastDate: DateTime(2101),
    );
    if (picked != null) setState(() => _selectedDate = picked);
  }

  Future<void> _saveData({required bool shouldDismissKeyboard}) async {
    final amountText = _amountController.text;
    if (amountText.isEmpty || amountText == "0") {
      if (shouldDismissKeyboard) _amountFocusNode.unfocus();
      return;
    }

    final newItem = TransactionItem(
      amount: int.tryParse(amountText) ?? 0,
      expense: _selectedExpenseIndex != null
          ? expenseTags[_selectedExpenseIndex!].label
          : '未分類',
      payment: _selectedPaymentIndex != null
          ? paymentTags[_selectedPaymentIndex!].label
          : '現金',
      date: DateTime(
        _selectedDate.year,
        _selectedDate.month,
        _selectedDate.day,
        DateTime.now().hour,
        DateTime.now().minute,
      ),
    );

    await _repository.addTransaction(newItem);

    setState(() {
      _amountController.clear();
      _selectedExpenseIndex = null;
      _selectedPaymentIndex = null;
    });

    if (shouldDismissKeyboard) _amountFocusNode.unfocus();

    if (mounted) {
      ScaffoldMessenger.of(context).showSnackBar(
        const SnackBar(
          content: Text('保存しました'),
          duration: Duration(milliseconds: 500),
        ),
      );
    }
  }

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      key: _scaffoldKey,
      onDrawerChanged: (isOpened) {
        if (isOpened) _amountFocusNode.unfocus();
      },
      drawer: const AppDrawer(),
      body: GestureDetector(
        onTap: () => FocusScope.of(context).unfocus(),
        behavior: HitTestBehavior.opaque,
        child: Stack(
          children: [
            Column(
              children: [
                Expanded(
                  child: SingleChildScrollView(
                    padding: const EdgeInsets.fromLTRB(20, 80, 20, 0),
                    child: Column(
                      children: [
                        _buildAmountInput(),
                        const SizedBox(height: 15),
                        CategorySelector(
                          tags: expenseTags,
                          selectedIndex: _selectedExpenseIndex,
                          rowCount: 2,
                          onSelected: (i) =>
                              setState(() => _selectedExpenseIndex = i),
                        ),
                        const Divider(
                          height: 30,
                          thickness: 1,
                          color: Colors.black12,
                        ),
                        CategorySelector(
                          tags: paymentTags,
                          selectedIndex: _selectedPaymentIndex,
                          rowCount: 2,
                          onSelected: (i) =>
                              setState(() => _selectedPaymentIndex = i),
                        ),
                        const SizedBox(height: 20),
                      ],
                    ),
                  ),
                ),
                _buildActionButtons(),
              ],
            ),
            _buildMenuButton(),
          ],
        ),
      ),
    );
  }

  Widget _buildAmountInput() {
    return Row(
      crossAxisAlignment: CrossAxisAlignment.center,
      children: [
        const Text(
          '¥ ',
          style: TextStyle(
            fontSize: 44,
            color: Colors.black,
            fontWeight: FontWeight.bold,
          ),
        ),
        Expanded(
          child: TextField(
            controller: _amountController,
            focusNode: _amountFocusNode,
            autofocus: true,
            keyboardType: TextInputType.number,
            textAlign: TextAlign.right,
            style: const TextStyle(fontSize: 44, fontWeight: FontWeight.bold),
            decoration: const InputDecoration(
              hintText: '0',
              enabledBorder: UnderlineInputBorder(
                borderSide: BorderSide(color: Colors.black12, width: 2),
              ),
            ),
          ),
        ),
        const SizedBox(width: 10),
        Padding(
          padding: const EdgeInsets.only(top: 12),
          child: IconButton(
            onPressed: _pickDate,
            icon: Column(
              mainAxisSize: MainAxisSize.min,
              children: [
                const Icon(Icons.calendar_today, size: 20, color: Colors.blue),
                const SizedBox(height: 2),
                Text(
                  "${_selectedDate.month}/${_selectedDate.day}",
                  style: const TextStyle(
                    fontSize: 11,
                    color: Colors.blue,
                    fontWeight: FontWeight.bold,
                  ),
                ),
              ],
            ),
          ),
        ),
      ],
    );
  }

  Widget _buildActionButtons() {
    return Padding(
      padding: const EdgeInsets.symmetric(horizontal: 20, vertical: 15),
      child: Row(
        children: [
          Expanded(
            child: OutlinedButton(
              onPressed: () => _saveData(shouldDismissKeyboard: false),
              style: OutlinedButton.styleFrom(
                padding: const EdgeInsets.symmetric(vertical: 12),
              ),
              child: const Text('次へ'),
            ),
          ),
          const SizedBox(width: 10),
          Expanded(
            child: ElevatedButton(
              onPressed: () => _saveData(shouldDismissKeyboard: true),
              style: ElevatedButton.styleFrom(
                padding: const EdgeInsets.symmetric(vertical: 12),
                backgroundColor: Colors.blue,
                foregroundColor: Colors.white,
              ),
              child: const Text('完了'),
            ),
          ),
        ],
      ),
    );
  }

  Widget _buildMenuButton() {
    return Positioned(
      top: 45,
      left: 15,
      child: Container(
        decoration: const BoxDecoration(
          color: Colors.white,
          shape: BoxShape.circle,
          boxShadow: [BoxShadow(color: Colors.black12, blurRadius: 4)],
        ),
        child: IconButton(
          icon: const Icon(Icons.menu, color: Colors.blue, size: 24),
          onPressed: () => _scaffoldKey.currentState?.openDrawer(),
        ),
      ),
    );
  }
}

```


--- FILE: flutter_project/lib/screens/monthly_report_screen.dart ---
```dart
import 'package:flutter/material.dart';
import '../models/category_tag.dart';
import '../models/transaction_item.dart';
import '../repositories/transaction_repository.dart';

class MonthlyHistoryScreen extends StatefulWidget {
  const MonthlyHistoryScreen({super.key});
  @override
  State<MonthlyHistoryScreen> createState() => _MonthlyHistoryScreenState();
}

class _MonthlyHistoryScreenState extends State<MonthlyHistoryScreen> {
  final PageController _pageController = PageController(initialPage: 1000);

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      appBar: AppBar(title: const Text('月別レポート')),
      body: PageView.builder(
        controller: _pageController,
        itemBuilder: (context, index) {
          final d = DateTime(
            DateTime.now().year,
            DateTime.now().month + (index - 1000),
          );
          return MonthPage(year: d.year, month: d.month);
        },
      ),
    );
  }
}

class MonthPage extends StatefulWidget {
  final int year;
  final int month;
  const MonthPage({super.key, required this.year, required this.month});
  @override
  State<MonthPage> createState() => _MonthPageState();
}

class _MonthPageState extends State<MonthPage> {
  List<TransactionItem> _history = [];
  final TransactionRepository _repository = TransactionRepository();

  @override
  void initState() {
    super.initState();
    _load();
  }

  Future<void> _load() async {
    final allItems = await _repository.getAllTransactions();
    setState(() {
      _history = allItems.where((i) {
        return i.date.year == widget.year && i.date.month == widget.month;
      }).toList();
    });
  }

  @override
  Widget build(BuildContext context) {
    int total = _history.fold(0, (s, i) => s + i.amount);
    return Column(
      children: [
        Padding(
          padding: const EdgeInsets.all(10),
          child: Text(
            "${widget.year}年 ${widget.month}月",
            style: const TextStyle(fontSize: 20, fontWeight: FontWeight.bold),
          ),
        ),
        _buildSummaryCard(total),
        Expanded(
          child: ListView.builder(
            itemCount: _history.length,
            itemBuilder: (c, i) => ListTile(
              title: Text('¥${_history[i].amount} (${_history[i].expense})'),
              subtitle: Text(
                '${_history[i].payment} / ${_history[i].displayDate}',
              ),
            ),
          ),
        ),
      ],
    );
  }

  Widget _buildSummaryCard(int total) {
    return Card(
      margin: const EdgeInsets.all(15),
      color: Colors.blue.shade50,
      child: Padding(
        padding: const EdgeInsets.all(15),
        child: Column(
          children: [
            Text(
              '¥ $total',
              style: const TextStyle(fontSize: 32, fontWeight: FontWeight.bold),
            ),
            const Divider(),
            Wrap(
              spacing: 10,
              children: expenseTags.map((t) {
                int s = _history
                    .where((i) => i.expense == t.label)
                    .fold(0, (sum, i) => sum + i.amount);
                return s > 0
                    ? Text(
                        '${t.label}: ¥$s',
                        style: TextStyle(
                          color: t.color,
                          fontWeight: FontWeight.bold,
                        ),
                      )
                    : const SizedBox.shrink();
              }).toList(),
            ),
          ],
        ),
      ),
    );
  }
}

```


--- FILE: flutter_project/lib/widgets/category_selector.dart ---
```dart
import 'package:flutter/material.dart';
import '../models/category_tag.dart';

class CategorySelector extends StatelessWidget {
  final List<CategoryTag> tags;
  final int? selectedIndex;
  final int rowCount;
  final Function(int) onSelected;

  const CategorySelector({
    super.key,
    required this.tags,
    required this.selectedIndex,
    required this.rowCount,
    required this.onSelected,
  });

  @override
  Widget build(BuildContext context) {
    return SizedBox(
      height: rowCount == 2 ? 100 : 50,
      child: GridView.builder(
        scrollDirection: Axis.horizontal,
        gridDelegate: SliverGridDelegateWithFixedCrossAxisCount(
          crossAxisCount: rowCount,
          mainAxisSpacing: 6,
          crossAxisSpacing: 6,
          childAspectRatio: rowCount == 2 ? 0.45 : 0.4,
        ),
        itemCount: tags.length,
        itemBuilder: (context, index) {
          final tag = tags[index];
          final isSelected = selectedIndex == index;
          return ChoiceChip(
            label: Text(tag.label, style: const TextStyle(fontSize: 12)),
            selected: isSelected,
            onSelected: (_) => onSelected(index),
            shape: tag.isCircle
                ? const StadiumBorder()
                : RoundedRectangleBorder(
                    borderRadius: BorderRadius.circular(8),
                  ),
            selectedColor: tag.color.withOpacity(0.3),
            visualDensity: VisualDensity.compact,
          );
        },
      ),
    );
  }
}

```


--- FILE: flutter_project/lib/widgets/app_drawer.dart ---
```dart
import 'package:flutter/material.dart';
import '../models/category_tag.dart';
import '../screens/monthly_report_screen.dart';
import '../screens/history_screen.dart';

class AppDrawer extends StatelessWidget {
  const AppDrawer({super.key});

  @override
  Widget build(BuildContext context) {
    return Drawer(
      child: ListView(
        padding: EdgeInsets.zero,
        children: [
          const DrawerHeader(
            decoration: BoxDecoration(color: Colors.blue),
            child: Text(
              'メニュー',
              style: TextStyle(color: Colors.white, fontSize: 24),
            ),
          ),
          ListTile(
            leading: const Icon(Icons.calendar_month),
            title: const Text('月別レポート'),
            onTap: () {
              Navigator.pop(context);
              Navigator.push(
                context,
                MaterialPageRoute(
                  builder: (context) => const MonthlyHistoryScreen(),
                ),
              );
            },
          ),
          const Divider(),
          _buildSectionHeader("費目別"),
          ...expenseTags.map(
            (tag) => _buildFilterTile(context, tag, 'expense'),
          ),
          const SizedBox(height: 15),
          const Divider(),
          _buildSectionHeader("支払い方法別"),
          ...paymentTags.map(
            (tag) => _buildFilterTile(context, tag, 'payment'),
          ),
          const SizedBox(height: 20),
        ],
      ),
    );
  }

  Widget _buildSectionHeader(String title) {
    return Padding(
      padding: const EdgeInsets.only(left: 16, top: 10, bottom: 5),
      child: Text(
        title,
        style: const TextStyle(color: Colors.grey, fontSize: 12),
      ),
    );
  }

  Widget _buildFilterTile(
    BuildContext context,
    CategoryTag tag,
    String filterKey,
  ) {
    return ListTile(
      leading: Icon(
        filterKey == 'payment' ? Icons.payment : Icons.label,
        color: tag.color,
      ),
      title: Text(tag.label),
      onTap: () {
        Navigator.pop(context);
        Navigator.push(
          context,
          MaterialPageRoute(
            builder: (context) => HistoryScreen(
              filterValue: tag.label,
              filterKey: filterKey,
              color: tag.color,
            ),
          ),
        );
      },
    );
  }
}

```


--- FILE: lib/main.dart ---
```dart
import 'package:flutter/material.dart';
import 'screens/input_screen.dart';

void main() {
  runApp(const QuickKakeiboApp());
}

class QuickKakeiboApp extends StatelessWidget {
  const QuickKakeiboApp({super.key});
  @override
  Widget build(BuildContext context) {
    return MaterialApp(
      debugShowCheckedModeBanner: false,
      title: 'Quick Kakeibo',
      theme: ThemeData(useMaterial3: true, colorSchemeSeed: Colors.blue),
      home: const InputScreen(),
    );
  }
}

```


--- FILE: lib/repositories/settings_repository.dart ---
```dart
import 'package:flutter/material.dart';
import 'package:shared_preferences/shared_preferences.dart';
import '../models/category_tag.dart';

// ショートカット用のデータモデル
class ShortcutItem {
  final String label;
  final String key; // 'expense' or 'payment'
  final Color color;
  final IconData icon;
  final String id; // 保存用の識別子

  ShortcutItem({
    required this.label,
    required this.key,
    required this.color,
    required this.icon,
    required this.id,
  });
}

class SettingsRepository {
  static const String _key = 'shortcut_settings';
  static const String _defaultPaymentKey = 'default_payment_label'; // 追加

  // 全ての選択可能なショートカット候補
  List<ShortcutItem> getAllCandidates() {
    List<ShortcutItem> items = [];

    // 1. デフォルト（費目）
    items.add(
      ShortcutItem(
        label: 'デフォルト',
        key: 'expense',
        color: Colors.blueGrey,
        icon: Icons.bookmarks,
        id: 'def_expense',
      ),
    );

    // 2. 費目リスト
    for (var tag in expenseTags) {
      items.add(
        ShortcutItem(
          label: tag.label,
          key: 'expense',
          color: tag.color,
          icon: _getIconForLabel(tag.label),
          id: 'exp_${tag.label}',
        ),
      );
    }

    // 3. デフォルト（支払い・現金含む）
    items.add(
      ShortcutItem(
        label: 'デフォルト',
        key: 'payment',
        color: Colors.grey,
        icon: Icons.wallet, // お財布アイコン
        id: 'def_payment',
      ),
    );

    // 4. 支払い方法リスト
    for (var tag in paymentTags) {
      items.add(
        ShortcutItem(
          label: tag.label,
          key: 'payment',
          color: tag.color,
          icon: tag.label == 'クレジットカード' ? Icons.credit_card : Icons.payment,
          id: 'pay_${tag.label}',
        ),
      );
    }

    return items;
  }

  // 初期設定（保存データがない場合）
  List<String> get _defaultShortcutIds => [
    'def_expense', // デフォルト
    'exp_食費', // 食費
    'pay_クレジットカード', // クレカ
  ];

  // 保存されたショートカットIDリストを取得
  Future<List<String>> loadShortcutIds() async {
    final prefs = await SharedPreferences.getInstance();
    return prefs.getStringList(_key) ?? _defaultShortcutIds;
  }

  // ショートカットIDリストを保存
  Future<void> saveShortcutIds(List<String> ids) async {
    final prefs = await SharedPreferences.getInstance();
    await prefs.setStringList(_key, ids);
  }

  // IDリストから実際のオブジェクトリストへ変換して取得
  Future<List<ShortcutItem>> getActiveShortcuts() async {
    final savedIds = await loadShortcutIds();
    final all = getAllCandidates();

    // 保存された順序を維持してリストを作成
    List<ShortcutItem> active = [];
    for (var id in savedIds) {
      try {
        final item = all.firstWhere((e) => e.id == id);
        active.add(item);
      } catch (e) {
        // 定義が変わってIDが見つからない場合はスキップ
      }
    }
    return active;
  }

  // アイコンの自動判定（簡易実装）
  IconData _getIconForLabel(String label) {
    if (label.contains('食')) return Icons.restaurant;
    if (label.contains('日用')) return Icons.shopping_bag;
    if (label.contains('交際')) return Icons.people;
    if (label.contains('趣味')) return Icons.sports_esports;
    if (label.contains('雑')) return Icons.auto_awesome;
    return Icons.label;
  }

  // ▼▼▼ 以下、追加機能 ▼▼▼

  // デフォルトの支払い方法を取得
  Future<String?> loadDefaultPaymentMethod() async {
    final prefs = await SharedPreferences.getInstance();
    return prefs.getString(_defaultPaymentKey);
  }

  // デフォルトの支払い方法を保存
  Future<void> saveDefaultPaymentMethod(String label) async {
    final prefs = await SharedPreferences.getInstance();
    await prefs.setString(_defaultPaymentKey, label);
  }

  // 設定を削除（「設定なし」に戻す場合など）
  Future<void> clearDefaultPaymentMethod() async {
    final prefs = await SharedPreferences.getInstance();
    await prefs.remove(_defaultPaymentKey);
  }
}

```


--- FILE: lib/repositories/player_repository.dart ---
```dart
import 'package:shared_preferences/shared_preferences.dart';
import '../models/achievement.dart';
import '../models/shop_item.dart'; // 追加

class PlayerRepository {
  static const String _keyScore = 'player_total_score'; // CP
  static const String _keyRealSpending = 'player_real_spending'; // リアル支出
  static const String _keyXp = 'player_xp';
  static const String _keyInputCount = 'player_input_count';
  static const String _keyUnlockedAchievements = 'player_unlocked_ids';

  // ★追加キー
  static const String _keyPurchasedItems =
      'player_purchased_items'; // 購入済みアイテムIDリスト
  static const String _keyEquippedSkin = 'player_equipped_skin'; // 装備中のスキンID

  Future<Map<String, dynamic>> getPlayerStats() async {
    final prefs = await SharedPreferences.getInstance();
    final xp = prefs.getInt(_keyXp) ?? 0;
    final cp = prefs.getInt(_keyScore) ?? 0;
    final inputCount = prefs.getInt(_keyInputCount) ?? 0;
    final realSpending = prefs.getInt(_keyRealSpending) ?? cp;

    int level = 1 + (xp / 5000).floor();
    int currentLevelBaseXp = (level - 1) * 5000;
    int nextLevelBaseXp = level * 5000;
    double progress =
        (xp - currentLevelBaseXp) / (nextLevelBaseXp - currentLevelBaseXp);

    return {
      'level': level,
      'xp': xp,
      'progress': progress,
      'cp': cp,
      'realSpending': realSpending,
      'inputCount': inputCount,
    };
  }

  // 現在の倍率（Multiplier）を計算して返す
  Future<double> getCurrentMultiplier() async {
    final prefs = await SharedPreferences.getInstance();
    final purchasedIds = prefs.getStringList(_keyPurchasedItems) ?? [];

    double multiplier = 1.0; // 基本倍率

    for (var item in darkWebItems) {
      if (item.type == ShopItemType.multiplier &&
          purchasedIds.contains(item.id)) {
        multiplier += (item.effectValue ?? 0.0);
      }
    }
    return multiplier;
  }

  // 現在装備中のスキンIDを取得
  Future<String?> getEquippedSkin() async {
    final prefs = await SharedPreferences.getInstance();
    return prefs.getString(_keyEquippedSkin);
  }

  // スキンを変更
  Future<void> equipSkin(String? skinId) async {
    final prefs = await SharedPreferences.getInstance();
    if (skinId == null) {
      await prefs.remove(_keyEquippedSkin);
    } else {
      await prefs.setString(_keyEquippedSkin, skinId);
    }
  }

  // アイテム購入処理
  Future<bool> purchaseItem(ShopItem item) async {
    final prefs = await SharedPreferences.getInstance();
    int currentCp = prefs.getInt(_keyScore) ?? 0;

    // お金が足りない
    if (currentCp < item.price) return false;

    // 支払い
    await prefs.setInt(_keyScore, currentCp - item.price);

    // アイテム付与
    List<String> purchased = prefs.getStringList(_keyPurchasedItems) ?? [];
    if (!purchased.contains(item.id)) {
      purchased.add(item.id);
      await prefs.setStringList(_keyPurchasedItems, purchased);
    }

    return true;
  }

  // 購入済みリスト取得
  Future<List<String>> getPurchasedItemIds() async {
    final prefs = await SharedPreferences.getInstance();
    return prefs.getStringList(_keyPurchasedItems) ?? [];
  }

  Future<List<String>> getUnlockedAchievementIds() async {
    final prefs = await SharedPreferences.getInstance();
    return prefs.getStringList(_keyUnlockedAchievements) ?? [];
  }

  // スコア加算（InputScreenで計算した最終CPを受け取る形に変更してもいいが、ここでは既存ロジックを維持）
  // ★修正: InputScreen側で倍率計算済みのCPを受け取るように引数を変更するのが筋だが、
  // 既存メソッド `addScoreAndCheckAchievements` は amount(元の金額) を受け取って内部でCP計算させたい。
  // しかし、倍率計算は非同期なので、InputScreen側で「金額 × 倍率」を計算して渡す形に変更する。

  // 新しい加算メソッド: amount(リアル) と gainedCp(ゲーム内) を分けて受け取る
  Future<List<Achievement>> addTransactionData({
    required int realAmount,
    required int gainedCp,
  }) async {
    final prefs = await SharedPreferences.getInstance();

    // 1. CP加算
    int currentCp = prefs.getInt(_keyScore) ?? 0;
    await prefs.setInt(_keyScore, currentCp + gainedCp);

    // 2. リアル支出加算
    int currentReal = prefs.getInt(_keyRealSpending) ?? currentCp; // 初期化対応
    await prefs.setInt(_keyRealSpending, currentReal + realAmount);

    // 3. XPと回数
    int currentXp = prefs.getInt(_keyXp) ?? 0;
    await prefs.setInt(_keyXp, currentXp + realAmount); // XPはリアル金額ベースが健全

    int currentCount = prefs.getInt(_keyInputCount) ?? 0;
    int newCount = currentCount + 1;
    await prefs.setInt(_keyInputCount, newCount);

    // 4. 実績解除チェック
    List<String> unlockedIds =
        prefs.getStringList(_keyUnlockedAchievements) ?? [];
    List<Achievement> newUnlocked = [];

    for (var achievement in allAchievements) {
      if (unlockedIds.contains(achievement.id)) continue;

      bool isUnlocked = false;
      if (achievement.type == AchievementType.totalAmount) {
        // 金額実績はインフレ後のCPで判定（気持ちよさ優先）
        if ((currentCp + gainedCp) >= achievement.threshold) isUnlocked = true;
      } else if (achievement.type == AchievementType.inputCount) {
        if (newCount >= achievement.threshold) isUnlocked = true;
      }

      if (isUnlocked) {
        unlockedIds.add(achievement.id);
        newUnlocked.add(achievement);
      }
    }

    if (newUnlocked.isNotEmpty) {
      await prefs.setStringList(_keyUnlockedAchievements, unlockedIds);
    }

    return newUnlocked;
  }

  // 旧メソッドは非推奨にするが、エラー回避のため残すか、InputScreenを修正する。
  // 今回はInputScreenを修正するので、この新しい `addTransactionData` を使う。
  Future<List<Achievement>> addScoreAndCheckAchievements(int amount) async {
    // 互換性維持のため、倍率1.0として処理
    return addTransactionData(realAmount: amount, gainedCp: amount);
  }
}

```


--- FILE: lib/repositories/familiar_repository.dart ---
```dart
import 'dart:math';
import 'package:shared_preferences/shared_preferences.dart';
import '../models/familiar.dart';

class FamiliarRepository {
  static const String _keyEggClicks = 'egg_current_clicks';
  static const String _keyHatchedCount = 'egg_hatched_count';
  static const String _keyCollection = 'familiar_collection_ids';

  // 現在の卵の状態を取得
  Future<Map<String, int>> getEggStatus() async {
    final prefs = await SharedPreferences.getInstance();
    final clicks = prefs.getInt(_keyEggClicks) ?? 0;
    final hatchedCount = prefs.getInt(_keyHatchedCount) ?? 0;

    // 必要クリック数計算: 最初は5回、以降 5 + (孵化数 * 5) ずつ増える
    // 例: 5, 10, 15, 20...
    final requiredClicks = 5 + (hatchedCount * 5);

    return {
      'current': clicks,
      'required': requiredClicks,
      'hatchedCount': hatchedCount,
    };
  }

  // 入力時に呼ぶ：クリック数を加算
  Future<void> addEggClick() async {
    final prefs = await SharedPreferences.getInstance();
    int current = prefs.getInt(_keyEggClicks) ?? 0;
    await prefs.setInt(_keyEggClicks, current + 1);
  }

  // 卵を割る処理
  Future<Familiar?> hatchEgg() async {
    final status = await getEggStatus();
    if (status['current']! < status['required']!) {
      return null; // まだ割れない
    }

    final prefs = await SharedPreferences.getInstance();

    // 1. カウントリセット & 孵化回数インクリメント
    await prefs.setInt(_keyEggClicks, 0);
    await prefs.setInt(_keyHatchedCount, status['hatchedCount']! + 1);

    // 2. 抽選ロジック
    final rnd = Random();
    final roll = rnd.nextInt(100); // 0-99

    // 確率設定
    int targetRarity;
    if (roll < 50)
      targetRarity = 1; // 50% Common
    else if (roll < 80)
      targetRarity = 2; // 30% Rare
    else if (roll < 95)
      targetRarity = 3; // 15% Epic
    else if (roll < 99)
      targetRarity = 4; // 4% Legendary
    else
      targetRarity = 5; // 1% God

    // 該当レアリティの中からランダムに1体選出
    final candidates = familiarMasterList
        .where((f) => f.rarity == targetRarity)
        .toList();
    // もし候補がいなければ(Godなど)、レアリティを下げて再検索（安全策）
    final hit = candidates.isNotEmpty
        ? candidates[rnd.nextInt(candidates.length)]
        : familiarMasterList[0];

    // 3. コレクションに追加
    final collection = prefs.getStringList(_keyCollection) ?? [];
    if (!collection.contains(hit.id)) {
      collection.add(hit.id);
      await prefs.setStringList(_keyCollection, collection);
    }

    return hit;
  }

  // 持っている使い魔リストを取得
  Future<List<Familiar>> getMyCollection() async {
    final prefs = await SharedPreferences.getInstance();
    final ids = prefs.getStringList(_keyCollection) ?? [];

    return familiarMasterList.where((f) => ids.contains(f.id)).toList();
  }
}

```


--- FILE: lib/repositories/transaction_repository.dart ---
```dart
import 'dart:convert';
import 'package:shared_preferences/shared_preferences.dart';
import '../models/transaction_item.dart';

class TransactionRepository {
  static const String _key = 'history';

  // 保存処理
  Future<void> addTransaction(TransactionItem item) async {
    final prefs = await SharedPreferences.getInstance();
    final List<TransactionItem> currentList = await getAllTransactions();

    // 新しいデータを先頭に追加
    currentList.insert(0, item);

    // JSON文字列に変換して保存
    final String jsonString = json.encode(
      currentList.map((e) => e.toJson()).toList(),
    );
    await prefs.setString(_key, jsonString);
  }

  // 全件取得処理
  Future<List<TransactionItem>> getAllTransactions() async {
    final prefs = await SharedPreferences.getInstance();
    final String? jsonString = prefs.getString(_key);

    if (jsonString == null) return [];

    final List<dynamic> jsonList = json.decode(jsonString);
    return jsonList.map((e) => TransactionItem.fromJson(e)).toList();
  }
}

```


--- FILE: lib/models/shop_item.dart ---
```dart
enum ShopItemType {
  multiplier, // 倍率アップ（インフレ）
  skin, // 見た目変更
}

class ShopItem {
  final String id;
  final String name;
  final String description;
  final int price;
  final ShopItemType type;
  final double? effectValue; // 倍率加算値など
  final String? skinAssetId; // スキン用ID

  const ShopItem({
    required this.id,
    required this.name,
    required this.description,
    required this.price,
    required this.type,
    this.effectValue,
    this.skinAssetId,
  });
}

// 闇市の商品リスト
final List<ShopItem> darkWebItems = [
  // --- インフレ加速装置 (Multiplier) ---
  const ShopItem(
    id: 'overclock_v1',
    name: 'CPU Overclock v1.0',
    description: 'CP獲得倍率を +0.1 加算する。初期衝動。',
    price: 1000,
    type: ShopItemType.multiplier,
    effectValue: 0.1,
  ),
  const ShopItem(
    id: 'gpu_boost',
    name: 'GPU Turbo Boost',
    description: 'CP獲得倍率を +0.2 加算する。描画負荷増大。',
    price: 5000,
    type: ShopItemType.multiplier,
    effectValue: 0.2,
  ),
  const ShopItem(
    id: 'crypto_miner',
    name: 'Illegal Miner',
    description: 'CP獲得倍率を +0.5 加算する。背徳の味。',
    price: 20000,
    type: ShopItemType.multiplier,
    effectValue: 0.5,
  ),
  const ShopItem(
    id: 'quantum_core',
    name: 'Quantum Core',
    description: 'CP獲得倍率を +1.0 加算する。物理法則の無視。',
    price: 100000,
    type: ShopItemType.multiplier,
    effectValue: 1.0,
  ),

  // --- スキン (Visual Hacks) ---
  const ShopItem(
    id: 'skin_matrix',
    name: 'VISUAL HACK: MATRIX',
    description: '攻撃エフェクトを「デジタルコード」に書き換える。',
    price: 3000,
    type: ShopItemType.skin,
    skinAssetId: 'matrix',
  ),
  const ShopItem(
    id: 'skin_gem',
    name: 'VISUAL HACK: GREED',
    description: '攻撃エフェクトを「宝石」に書き換える。',
    price: 10000,
    type: ShopItemType.skin,
    skinAssetId: 'gem',
  ),
];

```


--- FILE: lib/models/transaction_item.dart ---
```dart
class TransactionItem {
  final int amount;
  final String expense;
  final String payment;
  final DateTime date;
  final String? memo; // 追加: 任意のメモ

  TransactionItem({
    required this.amount,
    required this.expense,
    required this.payment,
    required this.date,
    this.memo,
  });

  // 表示用日付フォーマット
  String get displayDate {
    return "${date.month}/${date.day} ${date.hour}:${date.minute.toString().padLeft(2, '0')}";
  }

  // JSON保存用: Mapに変換
  Map<String, dynamic> toJson() {
    return {
      'amount': amount,
      'expense': expense,
      'payment': payment,
      'date_iso': date.toIso8601String(),
      'memo': memo, // 追加
    };
  }

  // 読み込み用: Mapから生成
  factory TransactionItem.fromJson(Map<String, dynamic> json) {
    return TransactionItem(
      amount: json['amount'] as int,
      expense: json['expense'] as String,
      payment: json['payment'] as String,
      date: DateTime.parse(json['date_iso'] as String),
      memo: json['memo'] as String?, // 追加
    );
  }
}

```


--- FILE: lib/models/category_tag.dart ---
```dart
import 'package:flutter/material.dart';

class CategoryTag {
  final String label;
  final Color color;
  final bool isCircle;

  const CategoryTag(this.label, this.color, {this.isCircle = false});
}

// 定数データ
final List<CategoryTag> expenseTags = [
  // ▼▼ 修正: 「デフォルト」は選択肢には表示しないため削除 ▼▼
  CategoryTag('食費', Colors.orange, isCircle: true),
  CategoryTag('日用品', Colors.green, isCircle: true),
  CategoryTag('雑費', Colors.blueGrey, isCircle: true),
  CategoryTag('交際費', Colors.pink, isCircle: true),
  CategoryTag('趣味', Colors.purple, isCircle: true),
];

final List<CategoryTag> paymentTags = [
  // ▼▼ 修正: 「現金」を選択肢として復活 ▼▼
  CategoryTag('現金', Colors.grey),
  CategoryTag('クレジットカード', Colors.blue),
  CategoryTag('PayPay', Colors.redAccent),
  CategoryTag('Suica', Colors.lightGreen),
];

```


--- FILE: lib/models/achievement.dart ---
```dart
import 'package:flutter/material.dart';

enum AchievementType {
  totalAmount, // 累計金額
  inputCount, // 入力回数
}

class Achievement {
  final String id;
  final String title;
  final String description;
  final AchievementType type;
  final int threshold; // 解除に必要な値（金額 or 回数）
  final IconData icon;

  const Achievement({
    required this.id,
    required this.title,
    required this.description,
    required this.type,
    required this.threshold,
    required this.icon,
  });
}

// ★★★ 実績マスターデータ ★★★
final List<Achievement> allAchievements = [
  // --- 入力回数系（継続こそ力なり） ---
  const Achievement(
    id: 'count_1',
    title: 'First Strike',
    description: '記念すべき最初の一撃（入力）',
    type: AchievementType.inputCount,
    threshold: 1,
    icon: Icons.star_border,
  ),
  const Achievement(
    id: 'count_3',
    title: 'Combo Starter',
    description: '3回の入力を達成。リズムに乗ってきた',
    type: AchievementType.inputCount,
    threshold: 3,
    icon: Icons.repeat,
  ),
  const Achievement(
    id: 'count_10',
    title: 'Habitual Striker',
    description: '10回の入力。習慣の芽生え',
    type: AchievementType.inputCount,
    threshold: 10,
    icon: Icons.history_edu,
  ),
  const Achievement(
    id: 'count_50',
    title: 'Machine Gun Finger',
    description: '50回の入力。指先から煙が出ている',
    type: AchievementType.inputCount,
    threshold: 50,
    icon: Icons.touch_app,
  ),
  const Achievement(
    id: 'count_100',
    title: 'Budget Warrior',
    description: '100回の入力。もはや家計簿は戦いだ',
    type: AchievementType.inputCount,
    threshold: 100,
    icon: Icons.military_tech,
  ),

  // --- 金額系（破壊力） ---
  const Achievement(
    id: 'amount_1000',
    title: 'Pocket Change',
    description: '累計1,000円。戦いは始まったばかり',
    type: AchievementType.totalAmount,
    threshold: 1000,
    icon: Icons.monetization_on_outlined,
  ),
  const Achievement(
    id: 'amount_10000',
    title: 'Wallet Breaker',
    description: '累計1万円。財布の紐が緩み始めた',
    type: AchievementType.totalAmount,
    threshold: 10000,
    icon: Icons.money_off,
  ),
  const Achievement(
    id: 'amount_50000',
    title: 'Economy Mover',
    description: '累計5万円。経済を回している自覚',
    type: AchievementType.totalAmount,
    threshold: 50000,
    icon: Icons.trending_up,
  ),
  const Achievement(
    id: 'amount_100000',
    title: 'Big Spender',
    description: '累計10万円。桁が変わる快感',
    type: AchievementType.totalAmount,
    threshold: 100000,
    icon: Icons.diamond,
  ),
  const Achievement(
    id: 'amount_500000',
    title: 'Capitalism Hero',
    description: '累計50万円。君は資本主義の英雄だ',
    type: AchievementType.totalAmount,
    threshold: 500000,
    icon: Icons.rocket_launch,
  ),
];

```


--- FILE: lib/models/familiar.dart ---
```dart
import 'package:flutter/material.dart';

class Familiar {
  final String id;
  final String name;
  final String description;
  final String emoji; // 画像の代わりに絵文字を使用（リッチに見せる加工は画面側で行う）
  final Color color;
  final int rarity; // 1~5

  const Familiar({
    required this.id,
    required this.name,
    required this.description,
    required this.emoji,
    required this.color,
    required this.rarity,
  });
}

// マスターデータ：サイバーパンク・ファミリア
final List<Familiar> familiarMasterList = [
  // Common (Rarity 1)
  Familiar(
    id: 'bit_slime',
    name: 'Bit Slime',
    description: 'データのカスから生まれたスライム',
    emoji: '💧',
    color: Colors.cyanAccent,
    rarity: 1,
  ),
  Familiar(
    id: 'bug_rat',
    name: 'Bug Rat',
    description: '配線をかじるのが好きなネズミ',
    emoji: '🐀',
    color: Colors.grey,
    rarity: 1,
  ),

  // Rare (Rarity 2)
  Familiar(
    id: 'neon_bat',
    name: 'Neon Bat',
    description: '超音波でWi-Fiを探知する',
    emoji: '🦇',
    color: Colors.purpleAccent,
    rarity: 2,
  ),
  Familiar(
    id: 'code_spider',
    name: 'Code Spider',
    description: 'バグを捕食する益虫',
    emoji: '🕷️',
    color: Colors.greenAccent,
    rarity: 2,
  ),

  // Epic (Rarity 3)
  Familiar(
    id: 'cyber_wolf',
    name: 'Cyber Wolf',
    description: '強固なファイアウォールを突破する牙',
    emoji: '🐺',
    color: Colors.blueAccent,
    rarity: 3,
  ),
  Familiar(
    id: 'glitch_ghost',
    name: 'Glitch Ghost',
    description: '存在したりしなかったりする幽霊',
    emoji: '👻',
    color: Colors.white70,
    rarity: 3,
  ),

  // Legendary (Rarity 4)
  Familiar(
    id: 'crypto_dragon',
    name: 'Crypto Dragon',
    description: 'ブロックチェーンの守護者',
    emoji: '🐉',
    color: Colors.orangeAccent,
    rarity: 4,
  ),
  Familiar(
    id: 'quantum_cat',
    name: 'Quantum Cat',
    description: '観測するまで生死が確定しない猫',
    emoji: '🐱',
    color: Colors.pinkAccent,
    rarity: 4,
  ),

  // God (Rarity 5)
  Familiar(
    id: 'singularity_eye',
    name: 'Singularity',
    description: '全ての収支を見通す神の目',
    emoji: '👁️',
    color: Colors.redAccent,
    rarity: 5,
  ),
];

```


--- FILE: lib/game/kakeibo_game.dart ---
```dart
import 'dart:async';
import 'dart:math';
import 'package:flame/components.dart';
import 'package:flame/game.dart';
import 'package:flame/effects.dart';
import 'package:flutter/material.dart';

// 攻撃スタイル (スキンIDを受け取れるように拡張)
class AttackStyle {
  final Color textColor;
  final Color coinColor;
  final double textScale;
  final int coinCount;
  final double shakeIntensity;
  final String? extraText;
  final Color? flashColor;

  // ★追加
  final String? skinId;

  AttackStyle({
    required this.textColor,
    required this.coinColor,
    required this.textScale,
    required this.coinCount,
    required this.shakeIntensity,
    this.extraText,
    this.flashColor,
    this.skinId,
  });

  factory AttackStyle.fromAmount(int amount, String? skinId) {
    // 既存の分岐ロジック (省略せず記述)
    AttackStyle base;
    if (amount >= 30000) {
      base = AttackStyle(
        textColor: const Color(0xFF00FFFF),
        coinColor: Colors.white,
        textScale: 2.5,
        coinCount: 200,
        shakeIntensity: 50.0,
        extraText: "GODLIKE!!!",
        flashColor: Colors.black,
        skinId: skinId, // 継承
      );
    } else if (amount >= 10000) {
      base = AttackStyle(
        textColor: const Color(0xFFFFD700),
        coinColor: const Color(0xFFFFD700),
        textScale: 2.0,
        coinCount: 100,
        shakeIntensity: 20.0,
        extraText: "LEGENDARY!",
        flashColor: Colors.white,
        skinId: skinId,
      );
    } else if (amount >= 5000) {
      base = AttackStyle(
        textColor: Colors.red,
        coinColor: Colors.red.shade100,
        textScale: 1.5,
        coinCount: 25,
        shakeIntensity: 9.0,
        extraText: "AMAZING!",
        skinId: skinId,
      );
    } else if (amount >= 1000) {
      base = AttackStyle(
        textColor: Colors.yellow,
        coinColor: Colors.yellow.shade100,
        textScale: 1.1,
        coinCount: 12,
        shakeIntensity: 5.0,
        extraText: "GOOD!",
        skinId: skinId,
      );
    } else {
      base = AttackStyle(
        textColor: Colors.white,
        coinColor: Colors.grey.shade300,
        textScale: 0.8,
        coinCount: 3,
        shakeIntensity: 1.0,
        skinId: skinId,
      );
    }
    return base;
  }
}

class KakeiboGame extends FlameGame {
  final Random _rnd = Random();

  @override
  Color backgroundColor() => const Color(0xFF1A1A2E);

  @override
  Future<void> onLoad() async {
    for (int i = 0; i < 50; i++) {
      add(StarComponent(size));
    }
  }

  // triggerAttackに skinId 引数を追加
  void triggerAttack(int amount, String categoryLabel, String? skinId) {
    final style = AttackStyle.fromAmount(amount, skinId);

    add(DamageTextComponent(amount, style, size));

    if (style.flashColor != null) {
      add(ScreenFlashComponent(size, color: style.flashColor!));
    }

    if (style.extraText != null) {
      add(ExtraTextComponent(style.extraText!, style, size));
    }

    for (int i = 0; i < style.coinCount; i++) {
      if (_rnd.nextDouble() < 0.2) {
        add(EmojiComponent(size, categoryLabel));
      } else {
        // ★スキンIDに応じてコンポーネントを切り替え
        if (skinId == 'matrix') {
          add(MatrixCodeComponent(size, style));
        } else if (skinId == 'gem') {
          add(GemComponent(size, style));
        } else {
          add(CoinComponent(size, style));
        }
      }
    }

    camera.viewfinder.add(
      SequenceEffect([
        MoveEffect.by(
          Vector2(style.shakeIntensity, 0),
          EffectController(duration: 0.05, alternate: true),
        ),
        MoveEffect.by(
          Vector2(-style.shakeIntensity, style.shakeIntensity),
          EffectController(duration: 0.05, alternate: true),
        ),
        MoveEffect.by(
          Vector2(style.shakeIntensity, style.shakeIntensity),
          EffectController(duration: 0.05, alternate: true),
        ),
        MoveEffect.by(
          Vector2(0, -style.shakeIntensity),
          EffectController(duration: 0.05, alternate: true),
        ),
      ]),
    );
  }
}

// ★新規スキン: マトリックスコード（緑の数字）
class MatrixCodeComponent extends TextComponent with HasGameRef {
  Vector2 velocity = Vector2.zero();
  final Vector2 gravity = Vector2(0, 800);

  MatrixCodeComponent(Vector2 screenSize, AttackStyle style) : super() {
    // ランダムな半角数字/文字
    final chars = ['0', '1', 'A', 'Z', 'X', '9'];
    text = chars[Random().nextInt(chars.length)];

    textRenderer = TextPaint(
      style: TextStyle(
        color: Colors.greenAccent,
        fontSize: 16 + (style.textScale * 4),
        fontFamily: 'Courier', // 等幅フォントっぽく
        shadows: [const Shadow(color: Colors.green, blurRadius: 5)],
      ),
    );

    position = Vector2(screenSize.x / 2, screenSize.y / 2 + 50);

    double angle = (Random().nextDouble() * pi) + pi;
    double speed = Random().nextDouble() * 300 + 200;
    velocity = Vector2(cos(angle) * speed, sin(angle) * speed);
  }

  @override
  void update(double dt) {
    super.update(dt);
    velocity += gravity * dt;
    position += velocity * dt;
    if (position.y > gameRef.size.y) removeFromParent();
  }
}

// ★新規スキン: 宝石（菱形）
class GemComponent extends PositionComponent with HasGameRef {
  Vector2 velocity = Vector2.zero();
  final Vector2 gravity = Vector2(0, 800);
  final Paint _paint;

  GemComponent(Vector2 screenSize, AttackStyle style)
    : _paint = Paint()..color = Colors.redAccent.withOpacity(0.8),
      super() {
    size = Vector2.all(10 + (style.textScale * 5));
    position = Vector2(screenSize.x / 2, screenSize.y / 2 + 50);

    double angle = (Random().nextDouble() * pi) + pi;
    double speed = Random().nextDouble() * 300 + 200;
    velocity = Vector2(cos(angle) * speed, sin(angle) * speed);
  }

  @override
  void render(Canvas canvas) {
    super.render(canvas);
    // 菱形を描く
    final path = Path()
      ..moveTo(size.x / 2, 0)
      ..lineTo(size.x, size.y / 2)
      ..lineTo(size.x / 2, size.y)
      ..lineTo(0, size.y / 2)
      ..close();
    canvas.drawPath(path, _paint);
    canvas.drawPath(
      path,
      Paint()
        ..style = PaintingStyle.stroke
        ..color = Colors.white
        ..strokeWidth = 1,
    );
  }

  @override
  void update(double dt) {
    super.update(dt);
    velocity += gravity * dt;
    position += velocity * dt;
    angle += dt * 5; // 回転
    if (position.y > gameRef.size.y) removeFromParent();
  }
}

// ... 以下、既存コンポーネント (ScreenFlash, Star, Coin, Emoji, Damage, Extra) はそのまま ...
// (長いので省略しますが、前回のコードにあるクラス定義はそのまま使ってください)
class ScreenFlashComponent extends PositionComponent {
  double opacity = 0.8;
  final Color color;
  ScreenFlashComponent(Vector2 screenSize, {required this.color}) : super() {
    size = screenSize;
    position = Vector2.zero();
    priority = 100;
  }
  @override
  void render(Canvas canvas) {
    super.render(canvas);
    canvas.drawRect(size.toRect(), Paint()..color = color.withOpacity(opacity));
  }

  @override
  void update(double dt) {
    super.update(dt);
    opacity -= dt * 5.0;
    if (opacity <= 0) removeFromParent();
  }
}

class StarComponent extends CircleComponent {
  StarComponent(Vector2 screenSize) : super(radius: 0) {
    double r = Random().nextDouble() * 2 + 1;
    radius = r;
    paint = Paint()
      ..color = Colors.white.withOpacity(Random().nextDouble() * 0.5 + 0.1);
    position = Vector2(
      Random().nextDouble() * screenSize.x,
      Random().nextDouble() * screenSize.y,
    );
  }
}

class CoinComponent extends CircleComponent with HasGameRef {
  Vector2 velocity = Vector2.zero();
  final Vector2 gravity = Vector2(0, 800);
  CoinComponent(Vector2 screenSize, AttackStyle style) : super(radius: 8) {
    paint = Paint()..color = style.coinColor;
    radius = 5.0 + (style.textScale * 2);
    position = Vector2(screenSize.x / 2, screenSize.y / 2 + 50);
    double angle = (Random().nextDouble() * pi) + pi;
    double speed = Random().nextDouble() * 200 * style.textScale + 200;
    velocity = Vector2(cos(angle) * speed, sin(angle) * speed);
  }
  @override
  void update(double dt) {
    super.update(dt);
    velocity += gravity * dt;
    position += velocity * dt;
    if (position.y > gameRef.size.y) removeFromParent();
  }
}

class EmojiComponent extends TextComponent with HasGameRef {
  Vector2 velocity = Vector2.zero();
  final Vector2 gravity = Vector2(0, 500);
  EmojiComponent(Vector2 screenSize, String category) : super() {
    String emoji = '💰';
    if (category.contains('食'))
      emoji = '🍔';
    else if (category.contains('日用'))
      emoji = '🧻';
    text = emoji;
    textRenderer = TextPaint(style: const TextStyle(fontSize: 24));
    position = Vector2(screenSize.x / 2, screenSize.y / 2 + 50);
    double angle = (Random().nextDouble() * pi) + pi;
    double speed = Random().nextDouble() * 400 + 100;
    velocity = Vector2(cos(angle) * speed, sin(angle) * speed);
  }
  @override
  void update(double dt) {
    super.update(dt);
    velocity += gravity * dt;
    position += velocity * dt;
    angle += dt * 5;
    if (position.y > gameRef.size.y) removeFromParent();
  }
}

class DamageTextComponent extends TextComponent {
  final Vector2 screenSize;
  DamageTextComponent(int amount, AttackStyle style, this.screenSize)
    : super() {
    text = '¥ $amount';
    textRenderer = TextPaint(
      style: TextStyle(
        fontSize: 40.0 * style.textScale,
        fontWeight: FontWeight.w900,
        color: style.textColor,
        shadows: [
          Shadow(
            blurRadius: 10 * style.textScale,
            color: style.coinColor.withOpacity(0.8),
            offset: Offset(2 * style.textScale, 2 * style.textScale),
          ),
        ],
      ),
    );
  }
  @override
  Future<void> onLoad() async {
    position = Vector2(screenSize.x / 2 - size.x / 2, screenSize.y / 2 - 100);
    add(
      ScaleEffect.to(
        Vector2.all(1.5),
        EffectController(duration: 0.1, curve: Curves.easeOut),
      ),
    );
    add(
      MoveEffect.by(
        Vector2(0, -150),
        EffectController(duration: 0.8, curve: Curves.easeOut),
        onComplete: () => removeFromParent(),
      ),
    );
  }
}

class ExtraTextComponent extends TextComponent with HasGameRef {
  ExtraTextComponent(String text, AttackStyle style, Vector2 screenSize)
    : super() {
    this.text = text;
    textRenderer = TextPaint(
      style: TextStyle(
        fontSize: 32 * style.textScale,
        fontWeight: FontWeight.bold,
        color: Colors.white,
        shadows: [
          Shadow(
            color: style.textColor,
            blurRadius: 10,
            offset: const Offset(3, 3),
          ),
        ],
      ),
    );
    position = Vector2(screenSize.x / 2 - (size.x / 2), 120);
  }
  @override
  Future<void> onLoad() async {
    add(
      ScaleEffect.to(
        Vector2.all(1.2),
        EffectController(
          duration: 0.2,
          alternate: true,
          repeatCount: 3,
          curve: Curves.elasticOut,
        ),
        onComplete: () => removeFromParent(),
      ),
    );
  }
}

```


--- FILE: lib/screens/history_screen.dart ---
```dart
import 'package:flutter/material.dart';
import '../models/transaction_item.dart';
import '../repositories/transaction_repository.dart';

class HistoryScreen extends StatefulWidget {
  final String filterValue;
  final String filterKey; // 'expense' or 'payment'
  final Color? color;

  const HistoryScreen({
    super.key,
    required this.filterValue,
    required this.filterKey,
    this.color,
  });

  @override
  State<HistoryScreen> createState() => _HistoryScreenState();
}

class _HistoryScreenState extends State<HistoryScreen> {
  List<TransactionItem> _allHistory = [];
  final TransactionRepository _repository = TransactionRepository();

  final PageController _pageController = PageController(initialPage: 1000);
  int _currentPage = 1000;

  @override
  void initState() {
    super.initState();
    _load();
  }

  Future<void> _load() async {
    final allItems = await _repository.getAllTransactions();
    setState(() {
      _allHistory = allItems.where((i) {
        if (widget.filterKey == 'expense') {
          return i.expense == widget.filterValue;
        }
        if (widget.filterKey == 'payment') {
          return i.payment == widget.filterValue;
        }
        return false;
      }).toList();
    });
  }

  DateTime _getDateForPage(int page) {
    final now = DateTime.now();
    return DateTime(now.year, now.month + (page - 1000));
  }

  @override
  Widget build(BuildContext context) {
    final currentMonthDate = _getDateForPage(_currentPage);

    return Scaffold(
      appBar: AppBar(title: Text(widget.filterValue), centerTitle: true),
      body: Column(
        children: [
          Container(
            padding: const EdgeInsets.symmetric(vertical: 10),
            color: Colors.white,
            child: Row(
              mainAxisAlignment: MainAxisAlignment.center,
              children: [
                IconButton(
                  onPressed: () {
                    _pageController.previousPage(
                      duration: const Duration(milliseconds: 300),
                      curve: Curves.easeInOut,
                    );
                  },
                  icon: const Icon(Icons.chevron_left),
                ),
                Padding(
                  padding: const EdgeInsets.symmetric(horizontal: 20),
                  child: Text(
                    "${currentMonthDate.year}年 ${currentMonthDate.month}月",
                    style: const TextStyle(
                      fontSize: 18,
                      fontWeight: FontWeight.bold,
                    ),
                  ),
                ),
                IconButton(
                  onPressed: () {
                    _pageController.nextPage(
                      duration: const Duration(milliseconds: 300),
                      curve: Curves.easeInOut,
                    );
                  },
                  icon: const Icon(Icons.chevron_right),
                ),
              ],
            ),
          ),

          Expanded(
            child: PageView.builder(
              controller: _pageController,
              onPageChanged: (index) {
                setState(() {
                  _currentPage = index;
                });
              },
              itemBuilder: (context, index) {
                return _buildMonthContent(index);
              },
            ),
          ),
        ],
      ),
    );
  }

  Widget _buildMonthContent(int pageIndex) {
    final date = _getDateForPage(pageIndex);
    final monthData = _allHistory.where((i) {
      return i.date.year == date.year && i.date.month == date.month;
    }).toList();

    int total = monthData.fold(0, (s, i) => s + i.amount);

    return Column(
      children: [
        Container(
          width: double.infinity,
          padding: const EdgeInsets.symmetric(vertical: 20, horizontal: 20),
          color: widget.color?.withOpacity(0.1) ?? Colors.blue.shade50,
          child: Center(
            child: Column(
              children: [
                Text(
                  '${date.month}月の合計',
                  style: const TextStyle(fontSize: 14, color: Colors.grey),
                ),
                Text(
                  '¥ $total',
                  style: TextStyle(
                    fontSize: 32,
                    fontWeight: FontWeight.bold,
                    color: widget.color ?? Colors.black,
                  ),
                ),
              ],
            ),
          ),
        ),

        Expanded(
          child: monthData.isEmpty
              ? const Center(
                  child: Text('履歴はありません', style: TextStyle(color: Colors.grey)),
                )
              : ListView.builder(
                  padding: const EdgeInsets.only(top: 10),
                  itemCount: monthData.length,
                  itemBuilder: (c, i) {
                    final item = monthData[i];

                    String detail = "";
                    if (widget.filterKey == 'expense') {
                      if (item.payment != 'デフォルト')
                        detail = "  /  ${item.payment}";
                    } else {
                      if (item.expense != 'デフォルト')
                        detail = "  /  ${item.expense}";
                    }

                    return ListTile(
                      leading: Icon(
                        widget.filterKey == 'payment'
                            ? Icons.payment
                            : Icons.label,
                        color: widget.color,
                      ),
                      title: Row(
                        children: [
                          Text(
                            '¥${item.amount}',
                            style: const TextStyle(fontWeight: FontWeight.bold),
                          ),
                          // メモがある場合はアイコンを表示
                          if (item.memo != null && item.memo!.isNotEmpty) ...[
                            const SizedBox(width: 8),
                            const Icon(
                              Icons.note,
                              size: 16,
                              color: Colors.grey,
                            ),
                          ],
                        ],
                      ),
                      subtitle: Column(
                        crossAxisAlignment: CrossAxisAlignment.start,
                        children: [
                          Text("${item.displayDate}$detail"),
                          // メモの内容を表示
                          if (item.memo != null && item.memo!.isNotEmpty)
                            Text(
                              item.memo!,
                              style: const TextStyle(
                                color: Colors.blueGrey,
                                fontSize: 12,
                              ),
                            ),
                        ],
                      ),
                    );
                  },
                ),
        ),
      ],
    );
  }
}

```


--- FILE: lib/screens/settings_screen.dart ---
```dart
import 'package:flutter/material.dart';
import '../repositories/settings_repository.dart';
import '../models/category_tag.dart';

class SettingsScreen extends StatefulWidget {
  const SettingsScreen({super.key});

  @override
  State<SettingsScreen> createState() => _SettingsScreenState();
}

class _SettingsScreenState extends State<SettingsScreen> {
  final SettingsRepository _repository = SettingsRepository();
  List<ShortcutItem> _allCandidates = [];
  List<String> _currentIds = [];
  String? _defaultPaymentLabel;

  @override
  void initState() {
    super.initState();
    _load();
  }

  Future<void> _load() async {
    final candidates = _repository.getAllCandidates();
    final ids = await _repository.loadShortcutIds();
    final defPayment = await _repository.loadDefaultPaymentMethod();
    setState(() {
      _allCandidates = candidates;
      _currentIds = ids;
      _defaultPaymentLabel = defPayment;
    });
  }

  Future<void> _toggle(String id, bool isEnabled) async {
    setState(() {
      if (isEnabled) {
        // 追加: 末尾に追加
        if (!_currentIds.contains(id)) {
          _currentIds.add(id);
        }
      } else {
        // 削除
        _currentIds.remove(id);
      }
    });
    await _repository.saveShortcutIds(_currentIds);
  }

  Future<void> _changeDefaultPayment(String? newValue) async {
    if (newValue == null) {
      await _repository.clearDefaultPaymentMethod();
    } else {
      await _repository.saveDefaultPaymentMethod(newValue);
    }
    setState(() {
      _defaultPaymentLabel = newValue;
    });
  }

  @override
  Widget build(BuildContext context) {
    // 費目グループと支払いグループに分ける
    final expenseItems = _allCandidates
        .where((i) => i.key == 'expense')
        .toList();
    final paymentItems = _allCandidates
        .where((i) => i.key == 'payment')
        .toList();

    return Scaffold(
      appBar: AppBar(title: const Text('設定')),
      body: ListView(
        children: [
          _buildHeader('入力の初期設定'),
          ListTile(
            title: const Text('デフォルトの支払い方法'),
            subtitle: const Text('入力画面を開いた時に最初から選択状態にします'),
            trailing: DropdownButton<String>(
              value: _defaultPaymentLabel,
              hint: const Text('指定なし'),
              underline: Container(), // 下線を消す
              items: [
                const DropdownMenuItem(value: null, child: Text('指定なし')),
                ...paymentTags.map((tag) {
                  return DropdownMenuItem(
                    value: tag.label,
                    child: Text(tag.label, style: TextStyle(color: tag.color)),
                  );
                }),
              ],
              onChanged: _changeDefaultPayment,
            ),
          ),
          const Divider(),
          _buildHeader('ホーム画面のショートカット'),
          const Padding(
            padding: EdgeInsets.symmetric(horizontal: 16, vertical: 8),
            child: Text(
              'ホーム画面中央に表示するボタンを選択してください。\n3つ程度がレイアウト的に最適です。',
              style: TextStyle(color: Colors.grey, fontSize: 12),
            ),
          ),
          const Divider(),
          _buildSectionLabel('費目'),
          ...expenseItems.map((item) => _buildSwitchTile(item)),
          const Divider(),
          _buildSectionLabel('支払い方法'),
          ...paymentItems.map((item) => _buildSwitchTile(item)),
          const SizedBox(height: 50),
        ],
      ),
    );
  }

  Widget _buildHeader(String title) {
    return Container(
      padding: const EdgeInsets.all(16),
      color: Colors.blue.withOpacity(0.1),
      child: Text(
        title,
        style: const TextStyle(
          fontSize: 18,
          fontWeight: FontWeight.bold,
          color: Colors.blue,
        ),
      ),
    );
  }

  Widget _buildSectionLabel(String label) {
    return Padding(
      padding: const EdgeInsets.fromLTRB(16, 16, 16, 8),
      child: Text(
        label,
        style: const TextStyle(fontWeight: FontWeight.bold, color: Colors.grey),
      ),
    );
  }

  Widget _buildSwitchTile(ShortcutItem item) {
    final isSelected = _currentIds.contains(item.id);
    return SwitchListTile(
      title: Text(item.label),
      subtitle: item.label == 'デフォルト'
          ? Text(item.key == 'expense' ? '未分類の費目' : '現金などのデフォルト支払い')
          : null,
      secondary: CircleAvatar(
        backgroundColor: item.color.withOpacity(0.1),
        child: Icon(item.icon, color: item.color, size: 20),
      ),
      value: isSelected,
      onChanged: (val) => _toggle(item.id, val),
      activeColor: Colors.blue,
    );
  }
}

```


--- FILE: lib/screens/input_screen.dart ---
```dart
import 'package:flutter/material.dart';
import 'package:flame/game.dart';
import 'package:google_fonts/google_fonts.dart';
import '../game/kakeibo_game.dart';
import '../models/category_tag.dart';
import '../models/transaction_item.dart';
import '../models/achievement.dart';
import '../repositories/transaction_repository.dart';
import '../repositories/settings_repository.dart';
import '../repositories/player_repository.dart';
import '../repositories/familiar_repository.dart';
import '../widgets/category_selector.dart';
import '../widgets/app_drawer.dart';
import '../widgets/number_keypad.dart';
import 'achievements_screen.dart';
import 'familiar_screen.dart';
import 'shop_screen.dart'; // 追加: 闇市画面

class InputScreen extends StatefulWidget {
  const InputScreen({super.key});
  @override
  State<InputScreen> createState() => _InputScreenState();
}

class _InputScreenState extends State<InputScreen> {
  final TextEditingController _amountController = TextEditingController();
  final GlobalKey<ScaffoldState> _scaffoldKey = GlobalKey<ScaffoldState>();

  final TransactionRepository _repository = TransactionRepository();
  final SettingsRepository _settingsRepository = SettingsRepository();
  final PlayerRepository _playerRepository = PlayerRepository();
  final FamiliarRepository _familiarRepository = FamiliarRepository();

  final KakeiboGame _game = KakeiboGame();

  List<ShortcutItem> _shortcuts = [];
  int? _selectedExpenseIndex;
  DateTime _selectedDate = DateTime.now();
  String _currentMemo = '';

  // プレイヤー統計
  int _totalCombatPower = 0;
  int _realSpending = 0;
  int _currentLevel = 1;
  double _xpProgress = 0.0;

  // ショップ関連データ
  double _currentMultiplier = 1.0;
  String? _currentSkin;

  // 実績通知用
  Achievement? _displayingAchievement;
  bool _isAchievementVisible = false;

  @override
  void initState() {
    super.initState();
    _loadShortcuts();
    _loadPlayerStats();
    _loadShopData(); // 倍率とスキンのロード
  }

  Future<void> _loadShortcuts() async {
    final items = await _settingsRepository.getActiveShortcuts();
    setState(() => _shortcuts = items);
  }

  Future<void> _loadPlayerStats() async {
    final stats = await _playerRepository.getPlayerStats();
    setState(() {
      _totalCombatPower = stats['cp'];
      _realSpending = stats['realSpending'];
      _currentLevel = stats['level'];
      _xpProgress = stats['progress'];
    });
  }

  Future<void> _loadShopData() async {
    final mult = await _playerRepository.getCurrentMultiplier();
    final skin = await _playerRepository.getEquippedSkin();
    setState(() {
      _currentMultiplier = mult;
      _currentSkin = skin;
    });
  }

  @override
  void dispose() {
    _amountController.dispose();
    super.dispose();
  }

  void _onKeyPressed(String value) {
    String currentText = _amountController.text;
    if (currentText == '0') currentText = '';
    if (currentText.length >= 9) return;
    setState(() => _amountController.text = currentText + value);
  }

  void _onDelete() {
    String currentText = _amountController.text;
    if (currentText.isNotEmpty) {
      setState(
        () => _amountController.text = currentText.substring(
          0,
          currentText.length - 1,
        ),
      );
    }
  }

  Future<void> _pickDate() async {
    final DateTime? picked = await showDatePicker(
      context: context,
      initialDate: _selectedDate,
      firstDate: DateTime(2000),
      lastDate: DateTime(2101),
    );
    if (picked != null) setState(() => _selectedDate = picked);
  }

  Future<void> _showMemoDialog() async {
    final TextEditingController memoController = TextEditingController(
      text: _currentMemo,
    );
    await showDialog(
      context: context,
      builder: (context) {
        return AlertDialog(
          backgroundColor: const Color(0xFF222244),
          title: Text(
            'MEMO INPUT',
            style: GoogleFonts.vt323(color: Colors.cyanAccent, fontSize: 24),
          ),
          content: TextField(
            controller: memoController,
            style: const TextStyle(color: Colors.white),
            autofocus: true,
            decoration: const InputDecoration(
              enabledBorder: UnderlineInputBorder(
                borderSide: BorderSide(color: Colors.cyan),
              ),
              focusedBorder: UnderlineInputBorder(
                borderSide: BorderSide(color: Colors.cyanAccent),
              ),
            ),
          ),
          actions: [
            TextButton(
              onPressed: () => Navigator.pop(context),
              child: const Text('CANCEL', style: TextStyle(color: Colors.grey)),
            ),
            TextButton(
              onPressed: () {
                setState(() => _currentMemo = memoController.text);
                Navigator.pop(context);
              },
              child: const Text(
                'OK',
                style: TextStyle(color: Colors.cyanAccent),
              ),
            ),
          ],
        );
      },
    );
  }

  Future<void> _executeAttack() async {
    final amountText = _amountController.text;
    if (amountText.isEmpty || amountText == "0") return;

    final amount = int.parse(amountText);
    String categoryName = '未分類';
    if (_selectedExpenseIndex != null) {
      categoryName = expenseTags[_selectedExpenseIndex!].label;
    }

    // 1. 家計簿データ保存
    final newItem = TransactionItem(
      amount: amount,
      expense: categoryName,
      payment: 'Default',
      date: DateTime(
        _selectedDate.year,
        _selectedDate.month,
        _selectedDate.day,
        DateTime.now().hour,
        DateTime.now().minute,
      ),
      memo: _currentMemo.isEmpty ? null : _currentMemo,
    );
    await _repository.addTransaction(newItem);

    // 2. CP計算 (インフレ倍率適用)
    int gainedCp = (amount * _currentMultiplier).toInt();

    // 3. プレイヤーデータ更新 & 実績チェック
    final unlockedAchievements = await _playerRepository.addTransactionData(
      realAmount: amount,
      gainedCp: gainedCp,
    );

    // 4. 実績解除通知
    if (unlockedAchievements.isNotEmpty) {
      _triggerAchievementPopup(unlockedAchievements);
    }

    // 5. 使い魔(卵)の育成
    await _familiarRepository.addEggClick();

    // 6. ゲーム演出 (スキンIDを渡す)
    _game.triggerAttack(amount, categoryName, _currentSkin);

    // 7. 表示更新
    await _loadPlayerStats();

    setState(() {
      _amountController.clear();
      _currentMemo = '';
    });
  }

  Future<void> _triggerAchievementPopup(List<Achievement> achievements) async {
    for (var item in achievements) {
      if (!mounted) return;
      setState(() {
        _displayingAchievement = item;
        _isAchievementVisible = true;
      });

      await Future.delayed(const Duration(seconds: 3));

      if (!mounted) return;
      setState(() {
        _isAchievementVisible = false;
      });

      await Future.delayed(const Duration(milliseconds: 300));
    }
  }

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      key: _scaffoldKey,
      drawer: AppDrawer(
        onSettingsChanged: () async {
          await _loadShortcuts();
        },
      ),
      backgroundColor: Colors.black,
      resizeToAvoidBottomInset: false,
      body: Stack(
        children: [
          // 1. ゲーム画面（上半分）
          Positioned.fill(
            bottom: MediaQuery.of(context).size.height * 0.4,
            child: ClipRect(child: GameWidget(game: _game)),
          ),

          // 2. CP & Level & Real Spending 表示
          Positioned(
            top: 50,
            left: 20,
            right: 20,
            child: Row(
              mainAxisAlignment: MainAxisAlignment.spaceBetween,
              crossAxisAlignment: CrossAxisAlignment.start,
              children: [
                Expanded(
                  child: Column(
                    crossAxisAlignment: CrossAxisAlignment.start,
                    children: [
                      FittedBox(
                        fit: BoxFit.scaleDown,
                        alignment: Alignment.centerLeft,
                        child: Text(
                          'COMBAT POWER',
                          style: GoogleFonts.pressStart2p(
                            color: Colors.cyanAccent,
                            fontSize: 10,
                          ),
                        ),
                      ),
                      const SizedBox(height: 5),
                      FittedBox(
                        fit: BoxFit.scaleDown,
                        alignment: Alignment.centerLeft,
                        child: Text(
                          '$_totalCombatPower',
                          style: GoogleFonts.vt323(
                            color: Colors.white,
                            fontSize: 40,
                            letterSpacing: 2,
                            shadows: [
                              const Shadow(color: Colors.blue, blurRadius: 15),
                            ],
                          ),
                        ),
                      ),
                      Row(
                        children: [
                          Icon(
                            Icons.currency_yen,
                            color: Colors.grey.shade600,
                            size: 12,
                          ),
                          Text(
                            "$_realSpending",
                            style: GoogleFonts.vt323(
                              color: Colors.grey.shade600,
                              fontSize: 14,
                            ),
                          ),
                        ],
                      ),
                    ],
                  ),
                ),
                const SizedBox(width: 16),
                Column(
                  crossAxisAlignment: CrossAxisAlignment.end,
                  children: [
                    Text(
                      'Lv.$_currentLevel',
                      style: GoogleFonts.pressStart2p(
                        color: Colors.yellowAccent,
                        fontSize: 20,
                        shadows: [
                          const Shadow(color: Colors.orange, blurRadius: 10),
                        ],
                      ),
                    ),
                    const SizedBox(height: 5),
                    SizedBox(
                      width: 100,
                      height: 6,
                      child: LinearProgressIndicator(
                        value: _xpProgress,
                        backgroundColor: Colors.grey.withOpacity(0.3),
                        color: Colors.greenAccent,
                        borderRadius: BorderRadius.circular(2),
                      ),
                    ),
                  ],
                ),
              ],
            ),
          ),

          // 3. コックピット（下半分）
          Align(
            alignment: Alignment.bottomCenter,
            child: Container(
              height: MediaQuery.of(context).size.height * 0.55,
              decoration: BoxDecoration(
                color: const Color(0xFF111122),
                borderRadius: const BorderRadius.vertical(
                  top: Radius.circular(30),
                ),
                border: const Border(
                  top: BorderSide(color: Colors.cyan, width: 2),
                ),
                boxShadow: [
                  BoxShadow(
                    color: Colors.cyanAccent.withOpacity(0.2),
                    blurRadius: 20,
                    offset: const Offset(0, -5),
                  ),
                ],
              ),
              child: Column(
                children: [
                  _buildStatusDisplay(),

                  // カテゴリ選択エリア
                  Expanded(
                    flex: 2,
                    child: SingleChildScrollView(
                      padding: const EdgeInsets.symmetric(
                        horizontal: 16,
                        vertical: 15,
                      ),
                      child: Column(
                        crossAxisAlignment: CrossAxisAlignment.start,
                        children: [
                          Text(
                            "TARGET CLASS",
                            style: GoogleFonts.pressStart2p(
                              color: Colors.grey,
                              fontSize: 8,
                            ),
                          ),
                          const SizedBox(height: 8),
                          CategorySelector(
                            tags: expenseTags,
                            selectedIndex: _selectedExpenseIndex,
                            rowCount: 1,
                            onSelected: (i) =>
                                setState(() => _selectedExpenseIndex = i),
                          ),
                        ],
                      ),
                    ),
                  ),

                  // キーパッド＆アクションエリア
                  Expanded(
                    flex: 6,
                    child: Padding(
                      padding: const EdgeInsets.fromLTRB(16, 0, 16, 20),
                      child: Row(
                        crossAxisAlignment: CrossAxisAlignment.stretch,
                        children: [
                          Expanded(
                            flex: 3,
                            child: NumberKeypad(
                              onKeyPressed: _onKeyPressed,
                              onDelete: _onDelete,
                            ),
                          ),
                          const SizedBox(width: 15),
                          Expanded(
                            flex: 1,
                            child: Column(
                              children: [
                                _buildSideButton(
                                  icon: Icons.calendar_today,
                                  label:
                                      "${_selectedDate.month}/${_selectedDate.day}",
                                  color: Colors.orangeAccent.withOpacity(0.2),
                                  textColor: Colors.orangeAccent,
                                  onTap: _pickDate,
                                ),
                                const SizedBox(height: 10),
                                _buildSideButton(
                                  icon: _currentMemo.isNotEmpty
                                      ? Icons.note
                                      : Icons.note_add_outlined,
                                  label: "MEMO",
                                  color: _currentMemo.isNotEmpty
                                      ? Colors.cyan.withOpacity(0.4)
                                      : Colors.white10,
                                  textColor: _currentMemo.isNotEmpty
                                      ? Colors.cyanAccent
                                      : Colors.grey,
                                  onTap: _showMemoDialog,
                                ),
                                const SizedBox(height: 10),
                                Expanded(
                                  child: Container(
                                    decoration: BoxDecoration(
                                      borderRadius: BorderRadius.circular(12),
                                      gradient: const LinearGradient(
                                        colors: [
                                          Color(0xFFFF4444),
                                          Color(0xFF990000),
                                        ],
                                        begin: Alignment.topLeft,
                                        end: Alignment.bottomRight,
                                      ),
                                      boxShadow: [
                                        BoxShadow(
                                          color: Colors.redAccent.withOpacity(
                                            0.5,
                                          ),
                                          blurRadius: 10,
                                          offset: const Offset(0, 4),
                                        ),
                                      ],
                                      border: Border.all(
                                        color: Colors.redAccent,
                                        width: 2,
                                      ),
                                    ),
                                    child: Material(
                                      color: Colors.transparent,
                                      child: InkWell(
                                        borderRadius: BorderRadius.circular(12),
                                        onTap: _executeAttack,
                                        child: Column(
                                          mainAxisAlignment:
                                              MainAxisAlignment.center,
                                          children: [
                                            const Icon(
                                              Icons.flash_on,
                                              size: 36,
                                              color: Colors.white,
                                            ),
                                            const SizedBox(height: 4),
                                            Text(
                                              'ATTACK',
                                              style: GoogleFonts.pressStart2p(
                                                fontSize: 10,
                                                color: Colors.white,
                                              ),
                                            ),
                                          ],
                                        ),
                                      ),
                                    ),
                                  ),
                                ),
                              ],
                            ),
                          ),
                        ],
                      ),
                    ),
                  ),
                ],
              ),
            ),
          ),

          // 4. 右側メニュー (Achievements, Familiar, Shop)
          Positioned(
            top: 100,
            right: 20,
            child: Column(
              children: [
                _buildSquareIconButton(
                  icon: Icons.menu,
                  color: Colors.cyanAccent,
                  onTap: () => _scaffoldKey.currentState?.openDrawer(),
                ),
                const SizedBox(height: 15),
                _buildSquareIconButton(
                  icon: Icons.emoji_events,
                  color: Colors.yellowAccent,
                  onTap: () async {
                    await Navigator.push(
                      context,
                      MaterialPageRoute(
                        builder: (context) => const AchievementsScreen(),
                      ),
                    );
                    _loadPlayerStats();
                  },
                ),
                const SizedBox(height: 15),
                _buildSquareIconButton(
                  icon: Icons.egg,
                  color: Colors.greenAccent,
                  onTap: () {
                    Navigator.push(
                      context,
                      MaterialPageRoute(
                        builder: (context) => const FamiliarScreen(),
                      ),
                    );
                  },
                ),
                const SizedBox(height: 15),
                // ショップボタン (THE DARK WEB)
                _buildSquareIconButton(
                  icon: Icons.shopping_cart,
                  color: Colors.redAccent,
                  onTap: () async {
                    await Navigator.push(
                      context,
                      MaterialPageRoute(
                        builder: (context) => const ShopScreen(),
                      ),
                    );
                    // 戻ってきたら最新データを反映
                    _loadPlayerStats();
                    _loadShopData();
                  },
                ),
              ],
            ),
          ),

          // 5. 実績解除ポップアップ (カスタム)
          Positioned(
            right: 75, // 右メニューの左
            top: 220, // トロフィーアイコン付近の高さ
            child: AnimatedOpacity(
              opacity: _isAchievementVisible ? 1.0 : 0.0,
              duration: const Duration(milliseconds: 300),
              child: _displayingAchievement != null
                  ? Container(
                      width: 200,
                      padding: const EdgeInsets.all(12),
                      decoration: BoxDecoration(
                        color: Colors.black.withOpacity(0.9),
                        borderRadius: BorderRadius.circular(8),
                        border: Border.all(
                          color: Colors.yellowAccent,
                          width: 2,
                        ),
                        boxShadow: [
                          BoxShadow(
                            color: Colors.yellow.withOpacity(0.3),
                            blurRadius: 10,
                          ),
                        ],
                      ),
                      child: Column(
                        crossAxisAlignment: CrossAxisAlignment.start,
                        children: [
                          Row(
                            children: [
                              const Icon(
                                Icons.emoji_events,
                                color: Colors.yellowAccent,
                                size: 20,
                              ),
                              const SizedBox(width: 8),
                              Text(
                                "UNLOCKED!",
                                style: GoogleFonts.pressStart2p(
                                  fontSize: 10,
                                  color: Colors.yellow,
                                ),
                              ),
                            ],
                          ),
                          const SizedBox(height: 8),
                          Text(
                            _displayingAchievement!.title,
                            style: GoogleFonts.orbitron(
                              fontSize: 14,
                              fontWeight: FontWeight.bold,
                              color: Colors.white,
                            ),
                          ),
                        ],
                      ),
                    )
                  : const SizedBox.shrink(),
            ),
          ),
        ],
      ),
    );
  }

  Widget _buildSquareIconButton({
    required IconData icon,
    required Color color,
    required VoidCallback onTap,
  }) {
    return Container(
      width: 44,
      height: 44,
      decoration: BoxDecoration(
        color: Colors.white.withOpacity(0.05),
        borderRadius: BorderRadius.circular(8),
        border: Border.all(color: color.withOpacity(0.8)),
        boxShadow: [BoxShadow(color: color.withOpacity(0.2), blurRadius: 8)],
      ),
      child: IconButton(
        padding: EdgeInsets.zero,
        icon: Icon(icon, color: color),
        onPressed: onTap,
      ),
    );
  }

  Widget _buildStatusDisplay() {
    return Container(
      width: double.infinity,
      margin: const EdgeInsets.fromLTRB(20, 20, 20, 0),
      padding: const EdgeInsets.symmetric(vertical: 10, horizontal: 20),
      decoration: BoxDecoration(
        color: Colors.black,
        borderRadius: BorderRadius.circular(8),
        border: Border.all(color: Colors.white24, width: 2),
      ),
      child: Row(
        mainAxisAlignment: MainAxisAlignment.spaceBetween,
        children: [
          Text(
            'CHARGE MODE',
            style: GoogleFonts.vt323(fontSize: 18, color: Colors.greenAccent),
          ),
          Row(
            crossAxisAlignment: CrossAxisAlignment.baseline,
            textBaseline: TextBaseline.alphabetic,
            children: [
              Text(
                _amountController.text.isEmpty ? '0' : _amountController.text,
                style: GoogleFonts.orbitron(
                  fontSize: 32,
                  fontWeight: FontWeight.bold,
                  color: Colors.cyanAccent,
                  shadows: [const Shadow(color: Colors.cyan, blurRadius: 10)],
                ),
              ),
              const SizedBox(width: 5),
              Text(
                'G',
                style: GoogleFonts.pressStart2p(
                  fontSize: 12,
                  color: Colors.orange,
                ),
              ),
            ],
          ),
        ],
      ),
    );
  }

  Widget _buildSideButton({
    required IconData icon,
    required String label,
    required Color color,
    required Color textColor,
    required VoidCallback onTap,
  }) {
    return InkWell(
      onTap: onTap,
      borderRadius: BorderRadius.circular(8),
      child: Container(
        width: double.infinity,
        padding: const EdgeInsets.symmetric(vertical: 10),
        decoration: BoxDecoration(
          color: color,
          borderRadius: BorderRadius.circular(8),
          border: Border.all(color: textColor.withOpacity(0.5)),
        ),
        child: Column(
          children: [
            Icon(icon, size: 18, color: textColor),
            const SizedBox(height: 2),
            Text(
              label,
              style: GoogleFonts.vt323(
                fontSize: 14,
                fontWeight: FontWeight.bold,
                color: textColor,
              ),
            ),
          ],
        ),
      ),
    );
  }
}

```


--- FILE: lib/screens/shop_screen.dart ---
```dart
import 'package:flutter/material.dart';
import 'package:google_fonts/google_fonts.dart';
import '../models/shop_item.dart';
import '../repositories/player_repository.dart';

class ShopScreen extends StatefulWidget {
  const ShopScreen({super.key});

  @override
  State<ShopScreen> createState() => _ShopScreenState();
}

class _ShopScreenState extends State<ShopScreen> {
  final PlayerRepository _repository = PlayerRepository();
  int _currentCp = 0;
  List<String> _purchasedIds = [];
  String? _equippedSkin;

  @override
  void initState() {
    super.initState();
    _loadData();
  }

  Future<void> _loadData() async {
    final stats = await _repository.getPlayerStats();
    final purchased = await _repository.getPurchasedItemIds();
    final skin = await _repository.getEquippedSkin();
    setState(() {
      _currentCp = stats['cp'];
      _purchasedIds = purchased;
      _equippedSkin = skin;
    });
  }

  Future<void> _purchase(ShopItem item) async {
    final success = await _repository.purchaseItem(item);
    if (success) {
      if (!mounted) return;
      ScaffoldMessenger.of(context).showSnackBar(
        const SnackBar(
          content: Text("TRANSACTION COMPLETE"),
          backgroundColor: Colors.green,
        ),
      );
      _loadData();
    } else {
      if (!mounted) return;
      ScaffoldMessenger.of(context).showSnackBar(
        const SnackBar(
          content: Text("INSUFFICIENT FUNDS"),
          backgroundColor: Colors.red,
        ),
      );
    }
  }

  Future<void> _equip(String skinId) async {
    // 既に装備中なら外す（トグル）
    if (_equippedSkin == skinId) {
      await _repository.equipSkin(null);
    } else {
      await _repository.equipSkin(skinId);
    }
    _loadData();
  }

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      backgroundColor: const Color(0xFF050505), // 深い黒
      appBar: AppBar(
        title: Text(
          'THE DARK WEB',
          style: GoogleFonts.vt323(fontSize: 24, color: Colors.redAccent),
        ),
        centerTitle: true,
        backgroundColor: Colors.black,
        iconTheme: const IconThemeData(color: Colors.redAccent),
        actions: [
          Center(
            child: Padding(
              padding: const EdgeInsets.only(right: 16),
              child: Text(
                'CP: $_currentCp',
                style: GoogleFonts.vt323(color: Colors.white, fontSize: 16),
              ),
            ),
          ),
        ],
      ),
      body: ListView.builder(
        padding: const EdgeInsets.all(16),
        itemCount: darkWebItems.length,
        itemBuilder: (context, index) {
          final item = darkWebItems[index];
          final isPurchased = _purchasedIds.contains(item.id);
          final isEquipped =
              item.type == ShopItemType.skin &&
              _equippedSkin == item.skinAssetId;

          return Container(
            margin: const EdgeInsets.only(bottom: 16),
            padding: const EdgeInsets.all(16),
            decoration: BoxDecoration(
              color: const Color(0xFF111111),
              border: Border.all(
                color: isPurchased
                    ? Colors.grey
                    : Colors.redAccent.withOpacity(0.5),
              ),
              borderRadius: BorderRadius.circular(8),
            ),
            child: Row(
              children: [
                // アイコン
                Container(
                  width: 50,
                  height: 50,
                  decoration: BoxDecoration(
                    color: Colors.black,
                    border: Border.all(
                      color: Colors.redAccent.withOpacity(0.3),
                    ),
                  ),
                  child: Icon(
                    item.type == ShopItemType.multiplier
                        ? Icons.bolt
                        : Icons.palette,
                    color: isPurchased ? Colors.grey : Colors.redAccent,
                  ),
                ),
                const SizedBox(width: 16),
                // 情報
                Expanded(
                  child: Column(
                    crossAxisAlignment: CrossAxisAlignment.start,
                    children: [
                      Text(
                        item.name,
                        style: GoogleFonts.vt323(
                          color: Colors.white,
                          fontSize: 20,
                        ),
                      ),
                      Text(
                        item.description,
                        style: const TextStyle(
                          color: Colors.grey,
                          fontSize: 12,
                        ),
                      ),
                      const SizedBox(height: 5),
                      Text(
                        "PRICE: ${item.price} CP",
                        style: GoogleFonts.vt323(
                          color: Colors.yellow,
                          fontSize: 14,
                        ),
                      ),
                    ],
                  ),
                ),
                // ボタン
                if (!isPurchased)
                  ElevatedButton(
                    onPressed: () => _purchase(item),
                    style: ElevatedButton.styleFrom(
                      backgroundColor: Colors.redAccent,
                      foregroundColor: Colors.black,
                    ),
                    child: const Text("BUY"),
                  )
                else if (item.type == ShopItemType.skin)
                  ElevatedButton(
                    onPressed: () => _equip(item.skinAssetId!),
                    style: ElevatedButton.styleFrom(
                      backgroundColor: isEquipped
                          ? Colors.green
                          : Colors.grey.shade800,
                      foregroundColor: Colors.white,
                    ),
                    child: Text(isEquipped ? "USED" : "EQUIP"),
                  )
                else
                  const Text(
                    "OWNED",
                    style: TextStyle(
                      color: Colors.grey,
                      fontWeight: FontWeight.bold,
                    ),
                  ),
              ],
            ),
          );
        },
      ),
    );
  }
}

```


--- FILE: lib/screens/achievements_screen.dart ---
```dart
import 'package:flutter/material.dart';
import 'package:google_fonts/google_fonts.dart';
import '../models/achievement.dart';
import '../repositories/player_repository.dart';

class AchievementsScreen extends StatefulWidget {
  const AchievementsScreen({super.key});

  @override
  State<AchievementsScreen> createState() => _AchievementsScreenState();
}

class _AchievementsScreenState extends State<AchievementsScreen> {
  final PlayerRepository _repository = PlayerRepository();
  List<String> _unlockedIds = [];
  int _inputCount = 0;
  int _totalAmount = 0;

  @override
  void initState() {
    super.initState();
    _loadData();
  }

  Future<void> _loadData() async {
    final stats = await _repository.getPlayerStats();
    // もしここでエラーが出る場合は、手順1のメソッドをPlayerRepositoryに追加してください
    final ids = await _repository.getUnlockedAchievementIds();

    setState(() {
      _inputCount = stats['inputCount'];
      // 【修正箇所】 totalAmount ではなく cp (Combat Power) を取得します
      _totalAmount = stats['cp'] ?? 0;
      _unlockedIds = ids;
    });
  }

  @override
  Widget build(BuildContext context) {
    // 解除率計算
    final progress = _unlockedIds.length / allAchievements.length;

    return Scaffold(
      backgroundColor: const Color(0xFF111122),
      appBar: AppBar(
        title: Text(
          'TROPHY ROOM',
          style: GoogleFonts.pressStart2p(fontSize: 16),
        ),
        backgroundColor: Colors.black,
        foregroundColor: Colors.white,
        elevation: 0,
      ),
      body: Column(
        children: [
          // ヘッダー部分（進捗表示）
          Container(
            padding: const EdgeInsets.all(20),
            decoration: const BoxDecoration(
              color: Colors.black,
              border: Border(bottom: BorderSide(color: Colors.cyan, width: 2)),
            ),
            child: Row(
              children: [
                CircularProgressIndicator(
                  value: progress,
                  backgroundColor: Colors.grey.shade800,
                  color: Colors.cyanAccent,
                  strokeWidth: 8,
                ),
                const SizedBox(width: 20),
                Column(
                  crossAxisAlignment: CrossAxisAlignment.start,
                  children: [
                    Text(
                      'UNLOCK PROGRESS',
                      style: GoogleFonts.vt323(
                        color: Colors.grey,
                        fontSize: 18,
                      ),
                    ),
                    Text(
                      '${(progress * 100).toInt()}% COMPLETE',
                      style: GoogleFonts.orbitron(
                        color: Colors.cyanAccent,
                        fontSize: 24,
                        fontWeight: FontWeight.bold,
                      ),
                    ),
                    const SizedBox(height: 5),
                    Text(
                      'TOTAL HITS: $_inputCount / TOTAL DMG: ¥$_totalAmount',
                      style: const TextStyle(
                        color: Colors.white54,
                        fontSize: 10,
                      ),
                    ),
                  ],
                ),
              ],
            ),
          ),

          // 実績リスト
          Expanded(
            child: ListView.builder(
              padding: const EdgeInsets.all(10),
              itemCount: allAchievements.length,
              itemBuilder: (context, index) {
                final item = allAchievements[index];
                final isUnlocked = _unlockedIds.contains(item.id);

                return _buildAchievementTile(item, isUnlocked);
              },
            ),
          ),
        ],
      ),
    );
  }

  Widget _buildAchievementTile(Achievement item, bool isUnlocked) {
    final color = isUnlocked ? Colors.cyanAccent : Colors.grey;
    final bgColor = isUnlocked
        ? Colors.cyan.withOpacity(0.1)
        : Colors.white.withOpacity(0.05);

    return Container(
      margin: const EdgeInsets.only(bottom: 10),
      decoration: BoxDecoration(
        color: bgColor,
        borderRadius: BorderRadius.circular(8),
        border: Border.all(
          color: isUnlocked ? Colors.cyan.withOpacity(0.5) : Colors.white10,
        ),
      ),
      child: ListTile(
        leading: Container(
          padding: const EdgeInsets.all(8),
          decoration: BoxDecoration(
            color: Colors.black,
            shape: BoxShape.circle,
            border: Border.all(color: color.withOpacity(0.5)),
            boxShadow: isUnlocked
                ? [BoxShadow(color: color.withOpacity(0.3), blurRadius: 10)]
                : [],
          ),
          child: Icon(
            isUnlocked ? item.icon : Icons.lock,
            color: color,
            size: 24,
          ),
        ),
        title: Text(
          isUnlocked ? item.title : '???',
          style: GoogleFonts.pressStart2p(
            color: isUnlocked ? Colors.white : Colors.white38,
            fontSize: 10,
          ),
        ),
        subtitle: Column(
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            const SizedBox(height: 5),
            Text(
              isUnlocked ? item.description : 'Unlock condition hidden',
              style: GoogleFonts.vt323(
                color: isUnlocked ? Colors.white70 : Colors.white24,
                fontSize: 16,
              ),
            ),
            if (!isUnlocked)
              Text(
                item.type == AchievementType.inputCount
                    ? 'Hint: Keep attacking... (${item.threshold} hits)'
                    : 'Hint: Increase damage... (¥${item.threshold})',
                style: const TextStyle(color: Colors.grey, fontSize: 10),
              ),
          ],
        ),
      ),
    );
  }
}

```


--- FILE: lib/screens/familiar_screen.dart ---
```dart
import 'package:flutter/material.dart';
import 'package:google_fonts/google_fonts.dart';
import '../models/familiar.dart';
import '../repositories/familiar_repository.dart';

class FamiliarScreen extends StatefulWidget {
  const FamiliarScreen({super.key});

  @override
  State<FamiliarScreen> createState() => _FamiliarScreenState();
}

class _FamiliarScreenState extends State<FamiliarScreen>
    with SingleTickerProviderStateMixin {
  final FamiliarRepository _repository = FamiliarRepository();

  int _currentClicks = 0;
  int _requiredClicks = 10;
  List<Familiar> _myCollection = [];

  late AnimationController _pulseController;

  @override
  void initState() {
    super.initState();
    _pulseController = AnimationController(
      vsync: this,
      duration: const Duration(seconds: 2),
    )..repeat(reverse: true);

    _loadData();
  }

  @override
  void dispose() {
    _pulseController.dispose();
    super.dispose();
  }

  Future<void> _loadData() async {
    final status = await _repository.getEggStatus();
    final collection = await _repository.getMyCollection();
    setState(() {
      _currentClicks = status['current']!;
      _requiredClicks = status['required']!;
      _myCollection = collection;
    });
  }

  Future<void> _tryHatch() async {
    if (_currentClicks < _requiredClicks) return;

    final newFamiliar = await _repository.hatchEgg();
    if (newFamiliar != null) {
      if (!mounted) return;
      // 孵化演出ダイアログ
      showDialog(
        context: context,
        barrierDismissible: false,
        builder: (context) => _buildHatchDialog(newFamiliar),
      );
      _loadData(); // データ更新
    }
  }

  // ★★★ 新規追加: 詳細閲覧ダイアログ ★★★
  void _showDetailDialog(Familiar familiar) {
    showDialog(
      context: context,
      builder: (context) => Dialog(
        backgroundColor: Colors.transparent,
        child: Container(
          padding: const EdgeInsets.all(20),
          decoration: BoxDecoration(
            color: const Color(0xFF0A0A12).withOpacity(0.95), // 背景を少し透過させてサイバー感
            borderRadius: BorderRadius.circular(16),
            border: Border.all(color: familiar.color, width: 2),
            boxShadow: [
              BoxShadow(
                color: familiar.color.withOpacity(0.3),
                blurRadius: 20,
                spreadRadius: 2,
              ),
            ],
          ),
          child: Column(
            mainAxisSize: MainAxisSize.min,
            children: [
              Text(
                "FAMILIAR DATA",
                style: GoogleFonts.orbitron(
                  color: Colors.white54,
                  fontSize: 12,
                  letterSpacing: 2,
                  fontWeight: FontWeight.bold,
                ),
              ),
              const SizedBox(height: 20),

              // アイコン
              Text(familiar.emoji, style: const TextStyle(fontSize: 80)),

              const SizedBox(height: 15),

              // 名前
              Text(
                familiar.name,
                style: GoogleFonts.pressStart2p(
                  color: familiar.color,
                  fontSize: 16,
                ),
                textAlign: TextAlign.center,
              ),

              const SizedBox(height: 10),

              // レアリティ
              Text(
                "★" * familiar.rarity,
                style: const TextStyle(color: Colors.yellow, fontSize: 14),
              ),

              const SizedBox(height: 20),

              // 説明文エリア
              Container(
                width: double.infinity,
                padding: const EdgeInsets.all(15),
                decoration: BoxDecoration(
                  color: Colors.white.withOpacity(0.05),
                  borderRadius: BorderRadius.circular(8),
                  border: Border.all(color: Colors.white12),
                ),
                child: Text(
                  familiar.description,
                  textAlign: TextAlign.center,
                  style: GoogleFonts.vt323(color: Colors.white, fontSize: 20),
                ),
              ),

              const SizedBox(height: 20),

              // 閉じるボタン
              SizedBox(
                width: double.infinity,
                child: OutlinedButton(
                  onPressed: () => Navigator.pop(context),
                  style: OutlinedButton.styleFrom(
                    side: const BorderSide(color: Colors.white24),
                    padding: const EdgeInsets.symmetric(vertical: 12),
                  ),
                  child: Text(
                    "CLOSE",
                    style: GoogleFonts.vt323(color: Colors.white, fontSize: 18),
                  ),
                ),
              ),
            ],
          ),
        ),
      ),
    );
  }

  @override
  Widget build(BuildContext context) {
    final progress = (_currentClicks / _requiredClicks).clamp(0.0, 1.0);
    final canHatch = _currentClicks >= _requiredClicks;

    return Scaffold(
      backgroundColor: const Color(0xFF0A0A12),
      appBar: AppBar(
        title: Text('BIO-LAB', style: GoogleFonts.pressStart2p(fontSize: 16)),
        backgroundColor: Colors.black,
        foregroundColor: Colors.white,
        actions: [
          Center(
            child: Padding(
              padding: const EdgeInsets.only(right: 16),
              child: Text(
                'COLLECTION: ${_myCollection.length}/${familiarMasterList.length}',
                style: GoogleFonts.vt323(
                  color: Colors.greenAccent,
                  fontSize: 16,
                ),
              ),
            ),
          ),
        ],
      ),
      body: Column(
        children: [
          // 上部：卵（培養槽）エリア
          Container(
            height: 300,
            width: double.infinity,
            decoration: const BoxDecoration(
              border: Border(
                bottom: BorderSide(color: Colors.greenAccent, width: 2),
              ),
              gradient: LinearGradient(
                colors: [Colors.black, Color(0xFF001100)],
                begin: Alignment.topCenter,
                end: Alignment.bottomCenter,
              ),
            ),
            child: Column(
              mainAxisAlignment: MainAxisAlignment.center,
              children: [
                Text(
                  canHatch ? "INCUBATION COMPLETE" : "INCUBATING...",
                  style: GoogleFonts.orbitron(
                    color: canHatch ? Colors.redAccent : Colors.greenAccent,
                    fontWeight: FontWeight.bold,
                    letterSpacing: 2,
                  ),
                ),
                const SizedBox(height: 20),

                // 卵本体
                GestureDetector(
                  onTap: canHatch ? _tryHatch : null,
                  child: ScaleTransition(
                    scale: Tween<double>(
                      begin: 0.95,
                      end: 1.05,
                    ).animate(_pulseController),
                    child: Container(
                      width: 120,
                      height: 150,
                      decoration: BoxDecoration(
                        color: Colors.black,
                        borderRadius: BorderRadius.circular(60),
                        border: Border.all(
                          color: canHatch
                              ? Colors.redAccent
                              : Colors.greenAccent,
                          width: 4,
                        ),
                        boxShadow: [
                          BoxShadow(
                            color: canHatch
                                ? Colors.red.withOpacity(0.5)
                                : Colors.green.withOpacity(0.3),
                            blurRadius: 30,
                            spreadRadius: 5,
                          ),
                        ],
                      ),
                      child: Center(
                        child: Text(
                          canHatch ? "!" : "${(progress * 100).toInt()}%",
                          style: GoogleFonts.vt323(
                            color: Colors.white,
                            fontSize: 32,
                            fontWeight: FontWeight.bold,
                          ),
                        ),
                      ),
                    ),
                  ),
                ),

                const SizedBox(height: 30),

                // プログレスバー
                Padding(
                  padding: const EdgeInsets.symmetric(horizontal: 50),
                  child: Column(
                    children: [
                      LinearProgressIndicator(
                        value: progress,
                        minHeight: 10,
                        backgroundColor: Colors.grey.shade900,
                        color: canHatch ? Colors.redAccent : Colors.greenAccent,
                      ),
                      const SizedBox(height: 8),
                      Text(
                        canHatch
                            ? "TAP EGG TO HATCH!"
                            : "DATA INPUT REQUIRED: $_currentClicks / $_requiredClicks",
                        style: GoogleFonts.vt323(
                          color: Colors.grey,
                          fontSize: 14,
                        ),
                      ),
                    ],
                  ),
                ),
              ],
            ),
          ),

          // 下部：コレクションリスト（修正済み）
          Expanded(
            child: _myCollection.isEmpty
                ? Center(
                    child: Text(
                      "NO FAMILIARS FOUND",
                      style: GoogleFonts.vt323(
                        color: Colors.white24,
                        fontSize: 24,
                      ),
                    ),
                  )
                : GridView.builder(
                    padding: const EdgeInsets.all(16),
                    gridDelegate:
                        const SliverGridDelegateWithFixedCrossAxisCount(
                          crossAxisCount: 3,
                          childAspectRatio: 0.8,
                          crossAxisSpacing: 10,
                          mainAxisSpacing: 10,
                        ),
                    itemCount: _myCollection.length,
                    itemBuilder: (context, index) {
                      final familiar = _myCollection[index];
                      // ★★★ InkWellでラップしてタップ可能にする ★★★
                      return Material(
                        color: Colors.transparent,
                        child: InkWell(
                          onTap: () => _showDetailDialog(familiar), // タップで詳細表示
                          borderRadius: BorderRadius.circular(8),
                          child: Container(
                            decoration: BoxDecoration(
                              color: Colors.white.withOpacity(0.05),
                              borderRadius: BorderRadius.circular(8),
                              border: Border.all(
                                color: familiar.color.withOpacity(0.5),
                              ),
                            ),
                            child: Column(
                              mainAxisAlignment: MainAxisAlignment.center,
                              children: [
                                Text(
                                  familiar.emoji,
                                  style: const TextStyle(fontSize: 40),
                                ),
                                const SizedBox(height: 5),
                                Text(
                                  familiar.name,
                                  textAlign: TextAlign.center,
                                  style: GoogleFonts.vt323(
                                    color: Colors.white,
                                    fontSize: 14,
                                  ),
                                ),
                                Text(
                                  "★" * familiar.rarity,
                                  style: const TextStyle(
                                    color: Colors.yellow,
                                    fontSize: 10,
                                  ),
                                ),
                              ],
                            ),
                          ),
                        ),
                      );
                    },
                  ),
          ),
        ],
      ),
    );
  }

  Widget _buildHatchDialog(Familiar familiar) {
    return Dialog(
      backgroundColor: Colors.transparent,
      child: Container(
        padding: const EdgeInsets.all(20),
        decoration: BoxDecoration(
          color: Colors.black,
          borderRadius: BorderRadius.circular(16),
          border: Border.all(color: familiar.color, width: 3),
          boxShadow: [
            BoxShadow(color: familiar.color.withOpacity(0.5), blurRadius: 20),
          ],
        ),
        child: Column(
          mainAxisSize: MainAxisSize.min,
          children: [
            Text(
              "NEW LIFEFORM DETECTED!",
              textAlign: TextAlign.center,
              style: GoogleFonts.orbitron(
                color: Colors.white,
                fontWeight: FontWeight.bold,
              ),
            ),
            const SizedBox(height: 20),
            Text(familiar.emoji, style: const TextStyle(fontSize: 80)),
            const SizedBox(height: 10),
            Text(
              familiar.name,
              style: GoogleFonts.pressStart2p(
                color: familiar.color,
                fontSize: 14,
              ),
            ),
            const SizedBox(height: 5),
            Text(
              "★" * familiar.rarity,
              style: const TextStyle(color: Colors.yellow, fontSize: 14),
            ),
            const SizedBox(height: 20),
            Text(
              familiar.description,
              textAlign: TextAlign.center,
              style: const TextStyle(color: Colors.white70),
            ),
            const SizedBox(height: 20),
            ElevatedButton(
              onPressed: () => Navigator.pop(context),
              style: ElevatedButton.styleFrom(
                backgroundColor: familiar.color,
                foregroundColor: Colors.black,
              ),
              child: const Text("CONFIRM"),
            ),
          ],
        ),
      ),
    );
  }
}

```


--- FILE: lib/screens/monthly_report_screen.dart ---
```dart
import 'package:flutter/material.dart';
import '../models/category_tag.dart';
import '../models/transaction_item.dart';
import '../repositories/transaction_repository.dart';

class MonthlyHistoryScreen extends StatefulWidget {
  const MonthlyHistoryScreen({super.key});
  @override
  State<MonthlyHistoryScreen> createState() => _MonthlyHistoryScreenState();
}

class _MonthlyHistoryScreenState extends State<MonthlyHistoryScreen> {
  // 初期位置を現在の月に設定 (1000ヶ月目を現在とする)
  final PageController _pageController = PageController(initialPage: 1000);

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      appBar: AppBar(title: const Text('月別レポート')),
      body: PageView.builder(
        controller: _pageController,
        itemBuilder: (context, index) {
          final d = DateTime(
            DateTime.now().year,
            DateTime.now().month + (index - 1000),
          );
          return MonthPage(year: d.year, month: d.month);
        },
      ),
    );
  }
}

class MonthPage extends StatefulWidget {
  final int year;
  final int month;
  const MonthPage({super.key, required this.year, required this.month});
  @override
  State<MonthPage> createState() => _MonthPageState();
}

class _MonthPageState extends State<MonthPage> {
  List<TransactionItem> _history = [];
  final TransactionRepository _repository = TransactionRepository();

  // 追加: 表示モードの切り替え（0:履歴, 1:分析）
  int _viewMode = 0;

  @override
  void initState() {
    super.initState();
    _load();
  }

  Future<void> _load() async {
    final allItems = await _repository.getAllTransactions();
    setState(() {
      _history = allItems.where((i) {
        return i.date.year == widget.year && i.date.month == widget.month;
      }).toList();
    });
  }

  @override
  Widget build(BuildContext context) {
    int total = _history.fold(0, (s, i) => s + i.amount);

    return Column(
      children: [
        // ヘッダー（年月表示）
        Padding(
          padding: const EdgeInsets.all(10),
          child: Text(
            "${widget.year}年 ${widget.month}月",
            style: const TextStyle(fontSize: 20, fontWeight: FontWeight.bold),
          ),
        ),

        // 合計金額カード
        _buildSummaryCard(total),

        // 表示切り替えスイッチ
        Container(
          margin: const EdgeInsets.symmetric(horizontal: 20, vertical: 5),
          decoration: BoxDecoration(
            color: Colors.grey.shade200,
            borderRadius: BorderRadius.circular(10),
          ),
          child: Row(
            children: [
              _buildSwitchButton('履歴', 0),
              _buildSwitchButton('分析', 1),
            ],
          ),
        ),
        const SizedBox(height: 10),

        // コンテンツ部分（履歴リスト or 分析グラフ）
        Expanded(
          child: _viewMode == 0
              ? _buildHistoryList()
              : _buildAnalysisView(total),
        ),
      ],
    );
  }

  Widget _buildSwitchButton(String label, int index) {
    final isSelected = _viewMode == index;
    return Expanded(
      child: GestureDetector(
        onTap: () => setState(() => _viewMode = index),
        child: Container(
          padding: const EdgeInsets.symmetric(vertical: 10),
          decoration: BoxDecoration(
            color: isSelected ? Colors.white : Colors.transparent,
            borderRadius: BorderRadius.circular(8),
            boxShadow: isSelected
                ? [const BoxShadow(color: Colors.black12, blurRadius: 2)]
                : null,
          ),
          child: Center(
            child: Text(
              label,
              style: TextStyle(
                fontWeight: FontWeight.bold,
                color: isSelected ? Colors.blue : Colors.grey,
              ),
            ),
          ),
        ),
      ),
    );
  }

  // 元の履歴リスト
  Widget _buildHistoryList() {
    if (_history.isEmpty) {
      return const Center(
        child: Text('データがありません', style: TextStyle(color: Colors.grey)),
      );
    }
    return ListView.builder(
      itemCount: _history.length,
      itemBuilder: (c, i) {
        final item = _history[i];
        final expenseStr = item.expense == 'デフォルト' ? '' : ' (${item.expense})';
        final paymentStr = item.payment == 'デフォルト' ? '' : '${item.payment} / ';
        return ListTile(
          title: Text('¥${item.amount}$expenseStr'),
          subtitle: Text('$paymentStr${item.displayDate}'),
        );
      },
    );
  }

  // 新規追加: 分析ビュー
  Widget _buildAnalysisView(int totalAmount) {
    if (totalAmount == 0) {
      return const Center(
        child: Text('データがありません', style: TextStyle(color: Colors.grey)),
      );
    }

    return SingleChildScrollView(
      padding: const EdgeInsets.symmetric(horizontal: 20, vertical: 10),
      child: Column(
        crossAxisAlignment: CrossAxisAlignment.start,
        children: [
          const Text(
            '費目別',
            style: TextStyle(fontWeight: FontWeight.bold, fontSize: 16),
          ),
          const SizedBox(height: 10),
          ..._buildRankList(isExpense: true, total: totalAmount),

          const Divider(height: 40),

          const Text(
            '支払い方法別',
            style: TextStyle(fontWeight: FontWeight.bold, fontSize: 16),
          ),
          const SizedBox(height: 10),
          ..._buildRankList(isExpense: false, total: totalAmount),
          const SizedBox(height: 30),
        ],
      ),
    );
  }

  List<Widget> _buildRankList({required bool isExpense, required int total}) {
    // 集計処理
    Map<String, int> sums = {};
    for (var item in _history) {
      final key = isExpense ? item.expense : item.payment;
      sums[key] = (sums[key] ?? 0) + item.amount;
    }

    // 金額順にソート
    final sortedKeys = sums.keys.toList()
      ..sort((a, b) => sums[b]!.compareTo(sums[a]!));

    // カテゴリ定義を取得（色などのため）
    final tags = isExpense ? expenseTags : paymentTags;

    return sortedKeys.map((key) {
      final amount = sums[key]!;
      final percent = (amount / total);

      // 色を探す（デフォルトの場合はグレー）
      Color color = Colors.grey;
      try {
        if (key != 'デフォルト') {
          color = tags.firstWhere((t) => t.label == key).color;
        }
      } catch (_) {}

      return Padding(
        padding: const EdgeInsets.only(bottom: 12),
        child: Column(
          children: [
            Row(
              mainAxisAlignment: MainAxisAlignment.spaceBetween,
              children: [
                Row(
                  children: [
                    Container(
                      width: 12,
                      height: 12,
                      decoration: BoxDecoration(
                        color: color,
                        shape: BoxShape.circle,
                      ),
                    ),
                    const SizedBox(width: 8),
                    Text(
                      key,
                      style: const TextStyle(fontWeight: FontWeight.bold),
                    ),
                  ],
                ),
                Text('¥$amount'),
              ],
            ),
            const SizedBox(height: 4),
            ClipRRect(
              borderRadius: BorderRadius.circular(4),
              child: LinearProgressIndicator(
                value: percent,
                backgroundColor: Colors.grey.shade200,
                color: color,
                minHeight: 8,
              ),
            ),
          ],
        ),
      );
    }).toList();
  }

  Widget _buildSummaryCard(int total) {
    return Card(
      margin: const EdgeInsets.all(15),
      color: Colors.blue.shade50,
      elevation: 0,
      child: Container(
        width: double.infinity,
        padding: const EdgeInsets.all(20),
        child: Column(
          children: [
            const Text('総支出', style: TextStyle(color: Colors.blueGrey)),
            Text(
              '¥ $total',
              style: const TextStyle(
                fontSize: 32,
                fontWeight: FontWeight.bold,
                color: Colors.blue,
              ),
            ),
          ],
        ),
      ),
    );
  }
}

```


--- FILE: lib/widgets/category_selector.dart ---
```dart
import 'package:flutter/material.dart';
import 'package:google_fonts/google_fonts.dart';
import '../models/category_tag.dart';

class CategorySelector extends StatelessWidget {
  final List<CategoryTag> tags;
  final int? selectedIndex;
  final int rowCount;
  final Function(int) onSelected;

  const CategorySelector({
    super.key,
    required this.tags,
    required this.selectedIndex,
    required this.rowCount,
    required this.onSelected,
  });

  @override
  Widget build(BuildContext context) {
    return SizedBox(
      height: 40, // 高さを少しコンパクトに
      child: ListView.separated(
        scrollDirection: Axis.horizontal,
        itemCount: tags.length,
        separatorBuilder: (context, index) => const SizedBox(width: 8),
        itemBuilder: (context, index) {
          final tag = tags[index];
          final isSelected = selectedIndex == index;

          // 色の決定（選択時はタグの色、非選択時は暗い色）
          final baseColor = tag.color;
          final bgColor = isSelected
              ? baseColor.withOpacity(0.2)
              : Colors.transparent;
          final borderColor = isSelected ? baseColor : Colors.white24;
          final textColor = isSelected ? baseColor : Colors.white54;

          return GestureDetector(
            onTap: () => onSelected(index),
            child: AnimatedContainer(
              duration: const Duration(milliseconds: 200),
              padding: const EdgeInsets.symmetric(horizontal: 12, vertical: 8),
              decoration: BoxDecoration(
                color: bgColor,
                border: Border.all(
                  color: borderColor,
                  width: isSelected ? 2 : 1,
                ),
                borderRadius: BorderRadius.circular(4), // 角張らせてSF感を出す
                boxShadow: isSelected
                    ? [
                        BoxShadow(
                          color: baseColor.withOpacity(0.5),
                          blurRadius: 8,
                        ),
                      ]
                    : [],
              ),
              child: Center(
                child: Text(
                  tag.label,
                  style: GoogleFonts.vt323(
                    // レトロPC風フォントがあればベストだが、なければ標準でOK
                    color: textColor,
                    fontSize: 16,
                    fontWeight: FontWeight.bold,
                  ),
                ),
              ),
            ),
          );
        },
      ),
    );
  }
}

```


--- FILE: lib/widgets/app_drawer.dart ---
```dart
import 'package:flutter/material.dart';
import '../models/category_tag.dart';
import '../screens/monthly_report_screen.dart';
import '../screens/history_screen.dart';
import '../screens/settings_screen.dart'; // 設定画面

class AppDrawer extends StatelessWidget {
  // 設定変更時にInputScreenを更新するためのコールバック
  final VoidCallback? onSettingsChanged;

  const AppDrawer({super.key, this.onSettingsChanged});

  @override
  Widget build(BuildContext context) {
    return Drawer(
      child: Column(
        // Columnに変更してSpacerを使えるようにする
        children: [
          Expanded(
            child: ListView(
              padding: EdgeInsets.zero,
              children: [
                const DrawerHeader(
                  decoration: BoxDecoration(color: Colors.blue),
                  child: Text(
                    'メニュー',
                    style: TextStyle(color: Colors.white, fontSize: 24),
                  ),
                ),
                ListTile(
                  leading: const Icon(Icons.calendar_month),
                  title: const Text('月別レポート'),
                  onTap: () {
                    Navigator.pop(context);
                    Navigator.push(
                      context,
                      MaterialPageRoute(
                        builder: (context) => const MonthlyHistoryScreen(),
                      ),
                    );
                  },
                ),
                const Divider(),
                _buildSectionHeader("費目別"),
                _buildFilterTile(
                  context,
                  const CategoryTag('デフォルト', Colors.blueGrey),
                  'expense',
                ),
                ...expenseTags.map(
                  (tag) => _buildFilterTile(context, tag, 'expense'),
                ),
                const SizedBox(height: 15),
                const Divider(),
                _buildSectionHeader("支払い方法別"),
                _buildFilterTile(
                  context,
                  const CategoryTag('デフォルト', Colors.grey),
                  'payment',
                ),
                ...paymentTags.map(
                  (tag) => _buildFilterTile(context, tag, 'payment'),
                ),
              ],
            ),
          ),
          const Divider(),
          // ▼▼ 設定ボタン（最下部） ▼▼
          ListTile(
            leading: const Icon(Icons.settings, color: Colors.grey),
            title: const Text('設定'),
            onTap: () async {
              // ドロワーを閉じる
              Navigator.pop(context);
              // 設定画面へ遷移し、戻ってくるのを待つ
              await Navigator.push(
                context,
                MaterialPageRoute(builder: (context) => const SettingsScreen()),
              );
              // 戻ってきたらコールバックを実行（InputScreenを更新）
              onSettingsChanged?.call();
            },
          ),
          const SizedBox(height: 20), // 下部の余白
        ],
      ),
    );
  }

  Widget _buildSectionHeader(String title) {
    return Padding(
      padding: const EdgeInsets.only(left: 16, top: 10, bottom: 5),
      child: Text(
        title,
        style: const TextStyle(color: Colors.grey, fontSize: 12),
      ),
    );
  }

  Widget _buildFilterTile(
    BuildContext context,
    CategoryTag tag,
    String filterKey,
  ) {
    return ListTile(
      leading: Icon(
        filterKey == 'payment' ? Icons.payment : Icons.label,
        color: tag.color,
      ),
      title: Text(tag.label),
      onTap: () {
        Navigator.pop(context);
        Navigator.push(
          context,
          MaterialPageRoute(
            builder: (context) => HistoryScreen(
              filterValue: tag.label,
              filterKey: filterKey,
              color: tag.color,
            ),
          ),
        );
      },
    );
  }
}

```


--- FILE: lib/widgets/number_keypad.dart ---
```dart
import 'package:flutter/material.dart';
import 'package:google_fonts/google_fonts.dart';

class NumberKeypad extends StatelessWidget {
  final Function(String) onKeyPressed;
  final VoidCallback onDelete;

  const NumberKeypad({
    super.key,
    required this.onKeyPressed,
    required this.onDelete,
  });

  @override
  Widget build(BuildContext context) {
    return Container(
      // 背景色削除（親側で管理）
      padding: const EdgeInsets.fromLTRB(0, 0, 10, 10),
      child: Column(
        mainAxisSize: MainAxisSize.min,
        children: [
          _buildRow(['7', '8', '9']),
          _buildRow(['4', '5', '6']),
          _buildRow(['1', '2', '3']),
          _buildRow(['00', '0', 'DEL']),
        ],
      ),
    );
  }

  Widget _buildRow(List<String> keys) {
    return Expanded(
      child: Row(
        children: keys.map((key) {
          return Expanded(
            child: Padding(
              padding: const EdgeInsets.all(4.0),
              child: _buildButton(key),
            ),
          );
        }).toList(),
      ),
    );
  }

  Widget _buildButton(String key) {
    final isDelete = key == 'DEL';

    return Material(
      color: Colors.transparent,
      child: InkWell(
        borderRadius: BorderRadius.circular(8),
        onTap: () {
          if (isDelete) {
            onDelete();
          } else {
            onKeyPressed(key);
          }
        },
        // ボタンのデザイン: 半透明の黒背景 + ネオンボーダー
        child: Container(
          decoration: BoxDecoration(
            color: Colors.white.withOpacity(0.05), // うっすら明るく
            border: Border.all(
              color: isDelete
                  ? Colors.redAccent.withOpacity(0.3)
                  : Colors.cyanAccent.withOpacity(0.1),
              width: 1,
            ),
            borderRadius: BorderRadius.circular(8),
            boxShadow: [
              // 押せる感じの影（内側）
              BoxShadow(
                color: Colors.black.withOpacity(0.5),
                blurRadius: 2,
                offset: const Offset(2, 2),
              ),
            ],
          ),
          child: Center(
            child: isDelete
                ? const Icon(
                    Icons.backspace_outlined,
                    color: Colors.redAccent,
                    size: 24,
                  )
                : Text(
                    key,
                    style: GoogleFonts.orbitron(
                      // SFチックな数字フォント
                      fontSize: 24,
                      fontWeight: FontWeight.bold,
                      color: Colors.cyanAccent,
                      shadows: [
                        const Shadow(color: Colors.blue, blurRadius: 5),
                      ],
                    ),
                  ),
          ),
        ),
      ),
    );
  }
}

```
